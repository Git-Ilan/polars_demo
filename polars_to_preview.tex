% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrartcl}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[many]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Intro 2 Polars},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Intro 2 Polars}
\author{}
\date{}

\begin{document}
\maketitle
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[breakable, interior hidden, sharp corners, borderline west={3pt}{0pt}{shadecolor}, enhanced, frame hidden, boxrule=0pt]}{\end{tcolorbox}}\fi

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ polars }\ImportTok{as}\NormalTok{ pl}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pyarrow }\ImportTok{as}\NormalTok{ pa}
\ImportTok{import}\NormalTok{ plotly.express }\ImportTok{as}\NormalTok{ px}
\ImportTok{import}\NormalTok{ string}
\ImportTok{import}\NormalTok{ random}
\ImportTok{import}\NormalTok{ os}
\ImportTok{import}\NormalTok{ sys}
\OperatorTok{\%}\NormalTok{matplotlib inline }
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ datetime}

\CommentTok{\# Following two lines only required to view plotly when rendering from VScode. }
\ImportTok{import}\NormalTok{ plotly.io }\ImportTok{as}\NormalTok{ pio}
\CommentTok{\# pio.renderers.default = "plotly\_mimetype+notebook\_connected+notebook"}
\NormalTok{pio.renderers.default }\OperatorTok{=} \StringTok{"plotly\_mimetype+notebook"}
\end{Highlighting}
\end{Shaded}

Inspecting polars version

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \%pip show polars \# check you polars version}
\CommentTok{\# \%pip show pandas \# check you polars version}
\end{Highlighting}
\end{Shaded}

\hypertarget{sec-motivation}{%
\section{Motivation}\label{sec-motivation}}

Each of the following, alone(!), is amazing.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Small memory footprint

  \begin{itemize}
  \tightlist
  \item
    Native dtypes: missing, strings.
  \item
    Arrow format in memory.
  \end{itemize}
\item
  Lazy evaluation allows query Planning.
\item
  Out of the box parallelism: Fast and informative messages for
  debugging.
\item
  Strict typing: This means the dtype of output is defined by the
  operation and not bu the input. This is both safer, and allows static
  analysis.
\end{enumerate}

\hypertarget{memory-footprint}{%
\subsection{Memory Footprint}\label{memory-footprint}}

\hypertarget{memory-footprint-of-storage}{%
\subsubsection{Memory Footprint of
Storage}\label{memory-footprint-of-storage}}

Polars vs.~Pandas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters }\OperatorTok{=}\NormalTok{ pl.Series(}\BuiltInTok{list}\NormalTok{(string.ascii\_letters))}

\NormalTok{n }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\FloatTok{10e6}\NormalTok{)}
\NormalTok{letter1 }\OperatorTok{=}\NormalTok{ letters.sample(n,with\_replacement}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{letter1.estimated\_size(unit}\OperatorTok{=}\StringTok{\textquotesingle{}gb\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.08381903916597366
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Pandas with Ver 1.x backend}
\NormalTok{letter1\_pandas }\OperatorTok{=}\NormalTok{ letter1.to\_pandas(use\_pyarrow\_extension\_array}\OperatorTok{=}\VariableTok{False}\NormalTok{) }
\NormalTok{letter1\_pandas.memory\_usage(deep}\OperatorTok{=}\VariableTok{True}\NormalTok{, index}\OperatorTok{=}\VariableTok{False}\NormalTok{) }\OperatorTok{/} \FloatTok{1e9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.58
\end{verbatim}

The memory footprint of the polars Series is 1/7 of the pandas
Series(!). But I did cheat- I used string type data to emphasize the
difference. The difference would have been smaller if I had used
integers or floats.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \# Pandas with Ver 2.x pyarrow backend}
\NormalTok{letter1\_pandas }\OperatorTok{=}\NormalTok{ letter1.to\_pandas(use\_pyarrow\_extension\_array}\OperatorTok{=}\VariableTok{True}\NormalTok{) }
\NormalTok{letter1\_pandas.memory\_usage(deep}\OperatorTok{=}\VariableTok{True}\NormalTok{, index}\OperatorTok{=}\VariableTok{False}\NormalTok{) }\OperatorTok{/} \FloatTok{1e9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.09
\end{verbatim}

The Pyarrow backend introduced in Pandas\textgreater{} 2.0, narrows the
gap between polars and pandas. But polars is still more efficient.

\hypertarget{memory-footprint-of-compute}{%
\subsubsection{Memory Footprint of
Compute}\label{memory-footprint-of-compute}}

You are probably storing your data to compute with it. Let's compare the
memory footprint of computations.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Will run on linux only}
\CommentTok{\# \%load\_ext memory\_profiler}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \%memit {-}r1 letter1.sort()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \%memit letter1\_pandas.sort\_values()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \%memit {-}r1 {-}n1 letter1[10]=\textquotesingle{}a\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \%memit letter1\_pandas[10]=\textquotesingle{}a\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Things to notice:

\begin{itemize}
\tightlist
\item
  Operating on existing data consumes less memory in polars than in
  pandas.
\item
  Changing the data consumes more memory in polars than in pandas. I
  suspect this has to do with the fact that the arrow memory schema used
  by polars
  \href{https://pola-rs.github.io/polars-book/user-guide/performance/strings.html}{is
  optimized}. Changing the data, may thus require re-allocation and
  optimization.
\end{itemize}

\hypertarget{operating-from-disk-to-disk}{%
\subsubsection{Operating From Disk to
Disk}\label{operating-from-disk-to-disk}}

What if my data does not fit into RAM? Turns out you manifest a lazy
frame into disk, instead of RAM, thus avoiding the need to load the
entire dataset into memory. Alas, the function that does so,
\href{https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/api/polars.LazyFrame.sink_parquet.html}{sink\_parquet()},
has currently limited functionality. It is certainly worth keeping an
eye on this function, as it matures.

\hypertarget{query-planning}{%
\subsection{Query Planning}\label{query-planning}}

Consider a sort operation that follows a filter operation. Ideally,
filter precedes the sort, but we did not ensure this\ldots{} We now
demonstrate that polars' query planner will do it for you. En passant,
we see polars is more efficient also without the query planner.

Polars' Eager evaluation, without query planning. Sort then filter.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n }\DecValTok{2} \OperatorTok{{-}}\NormalTok{r }\DecValTok{2}\NormalTok{ letter1.sort().}\BuiltInTok{filter}\NormalTok{(letter1.is\_in([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
284 ms ± 5.71 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Polars' Eager evaluation, without query planning. Filter then sort.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n }\DecValTok{2} \OperatorTok{{-}}\NormalTok{r }\DecValTok{2}\NormalTok{ letter1.}\BuiltInTok{filter}\NormalTok{(letter1.is\_in([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{])).sort()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
121 ms ± 7.84 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Polars' Lazy evaluation with query planning. Receives sort then filter;
executes filter then sort.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n }\DecValTok{2} \OperatorTok{{-}}\NormalTok{r }\DecValTok{2}\NormalTok{ letter1.alias(}\StringTok{\textquotesingle{}letters\textquotesingle{}}\NormalTok{).to\_frame().lazy().sort(by}\OperatorTok{=}\StringTok{\textquotesingle{}letters\textquotesingle{}}\NormalTok{).}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{\textquotesingle{}letters\textquotesingle{}}\NormalTok{).is\_in([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{])).collect()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
110 ms ± 2.71 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Pandas' eager evaluation in the wrong order: Sort then filter.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n1 }\OperatorTok{{-}}\NormalTok{r1 letter1\_pandas.sort\_values().loc[}\KeywordTok{lambda}\NormalTok{ x: x.isin([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{])]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1.64 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)
\end{verbatim}

Pandas eager evaluation in the right order: Filter then sort.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n1 }\OperatorTok{{-}}\NormalTok{r1 letter1\_pandas.loc[}\KeywordTok{lambda}\NormalTok{ x: x.isin([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{])].sort\_values()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
148 ms ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)
\end{verbatim}

Pandas alternative syntax, just as slow.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n }\DecValTok{2} \OperatorTok{{-}}\NormalTok{r }\DecValTok{2}\NormalTok{ letter1\_pandas.loc[letter1\_pandas.isin([}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{])].sort\_values()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
145 ms ± 884 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Things to note:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Query planning works!
\item
  Polars faster than Pandas even in eager evaluation (without query
  planning).
\end{enumerate}

\hypertarget{parallelism}{%
\subsection{Parallelism}\label{parallelism}}

Polars seamlessly parallelizes over columns (also within, when
possible). As the number of columns in the data grows, we would expect
fixed runtime until all cores are used, and then linear scaling. The
following code demonstrates this idea, using a simple sum-within-column.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ time}

\KeywordTok{def}\NormalTok{ scaling\_of\_sums(n\_rows, n\_cols):}
  \CommentTok{\# n\_cols = 2}
  \CommentTok{\# n\_rows = int(1e6)}
\NormalTok{  A }\OperatorTok{=}\NormalTok{ \{\}}
\NormalTok{  A\_numpy }\OperatorTok{=}\NormalTok{ np.random.randn(n\_rows,n\_cols)}
\NormalTok{  A[}\StringTok{\textquotesingle{}numpy\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ A\_numpy.copy()}
\NormalTok{  A[}\StringTok{\textquotesingle{}polars\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pl.DataFrame(A\_numpy)}
\NormalTok{  A[}\StringTok{\textquotesingle{}pandas\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.DataFrame(A\_numpy)}

\NormalTok{  times }\OperatorTok{=}\NormalTok{ \{\}}
  \ControlFlowTok{for}\NormalTok{ key,value }\KeywordTok{in}\NormalTok{ A.items():}
\NormalTok{    start }\OperatorTok{=}\NormalTok{ time.time() }
\NormalTok{    value.}\BuiltInTok{sum}\NormalTok{() }\CommentTok{\# sum over columns}
\NormalTok{    end }\OperatorTok{=}\NormalTok{ time.time()}
\NormalTok{    times[key] }\OperatorTok{=}\NormalTok{ end}\OperatorTok{{-}}\NormalTok{start }\CommentTok{\# get runtime}

  \ControlFlowTok{return}\NormalTok{(times)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scaling\_of\_time }\OperatorTok{=}\NormalTok{ \{}
\NormalTok{  p:scaling\_of\_sums(n\_rows}\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\FloatTok{1e6}\NormalTok{),n\_cols }\OperatorTok{=}\NormalTok{ p) }\ControlFlowTok{for}\NormalTok{ p }\KeywordTok{in}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{,}\DecValTok{16}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OperatorTok{=}\NormalTok{ pd.DataFrame(scaling\_of\_time).T}
\NormalTok{fig }\OperatorTok{=}\NormalTok{ px.line(}
\NormalTok{  data, }
\NormalTok{  labels}\OperatorTok{=}\BuiltInTok{dict}\NormalTok{(}
\NormalTok{    index}\OperatorTok{=}\StringTok{"Number of Columns"}\NormalTok{, }
\NormalTok{    value}\OperatorTok{=}\StringTok{"Runtime"}\NormalTok{)}
\NormalTok{)}
\NormalTok{fig.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unable to display output for mime type(s): text/html
\end{verbatim}

\begin{verbatim}
Unable to display output for mime type(s): application/vnd.plotly.v1+json, text/html
\end{verbatim}

Things to note:

\begin{itemize}
\tightlist
\item
  Pandas is slow.
\item
  Numpy is quite efficient.
\item
  My machine has 8 cores. I would thus expect a fixed timing until 8
  columns, and then linear scaling. This is not the case. I suspect that
  is because parallelism occurs not only between columns, but also
  within.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scaling\_of\_time\_2 }\OperatorTok{=}\NormalTok{ \{}
\NormalTok{  p:scaling\_of\_sums(n\_rows}\OperatorTok{=}\NormalTok{p ,n\_cols }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\FloatTok{1e5}\NormalTok{)) }\ControlFlowTok{for}\NormalTok{ p }\KeywordTok{in}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{,}\DecValTok{16}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OperatorTok{=}\NormalTok{ pd.DataFrame(scaling\_of\_time\_2).T}
\NormalTok{fig }\OperatorTok{=}\NormalTok{ px.line(}
\NormalTok{  data, }
\NormalTok{  labels}\OperatorTok{=}\BuiltInTok{dict}\NormalTok{(}
\NormalTok{    index}\OperatorTok{=}\StringTok{"Number of Rows"}\NormalTok{, }
\NormalTok{    value}\OperatorTok{=}\StringTok{"Runtime"}\NormalTok{)}
\NormalTok{)}
\NormalTok{fig.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unable to display output for mime type(s): application/vnd.plotly.v1+json, text/html
\end{verbatim}

Things to note:

\begin{itemize}
\tightlist
\item
  Summing over columns does not parallelize well in polars. This has to
  do with the fact that arrow stores data in a columnar format.
\end{itemize}

\hypertarget{speed-of-import}{%
\subsection{Speed Of Import}\label{speed-of-import}}

Polar's \texttt{read\_X} functions are quite faster than Pandas. This is
due to better type ``guessing'' heuristics, and easier mapping between
the disk representation and memory representation of the data.

We benchmark by making synthetic data, save it on disk, and reimporting
it.

Starting with CSV:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_rows }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\FloatTok{1e5}\NormalTok{)}
\NormalTok{n\_cols }\OperatorTok{=} \DecValTok{10}
\NormalTok{data\_polars }\OperatorTok{=}\NormalTok{ pl.DataFrame(np.random.randn(n\_rows,n\_cols))}
\NormalTok{data\_polars.write\_csv(}\StringTok{\textquotesingle{}data/data.csv\textquotesingle{}}\NormalTok{, has\_header }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{os}\SpecialCharTok{.}\NormalTok{path}\SpecialCharTok{.}\NormalTok{getsize(}\StringTok{\textquotesingle{}data/data.csv\textquotesingle{}}\NormalTok{)}\OperatorTok{/}\FloatTok{1e7}\SpecialCharTok{:.2f\}}\SpecialStringTok{ MB on disk"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'1.96 MB on disk'
\end{verbatim}

Import with pandas.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_pandas }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{\textquotesingle{}data/data.csv\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
79.6 ms ± 678 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Import with polars.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_polars }\OperatorTok{=}\NormalTok{ pl.read\_csv(}\StringTok{\textquotesingle{}data/data.csv\textquotesingle{}}\NormalTok{, has\_header }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5.34 ms ± 780 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Trying parquet format:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_polars.write\_parquet(}\StringTok{\textquotesingle{}data/data.parquet\textquotesingle{}}\NormalTok{)}
\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{os}\SpecialCharTok{.}\NormalTok{path}\SpecialCharTok{.}\NormalTok{getsize(}\StringTok{\textquotesingle{}data/data.parquet\textquotesingle{}}\NormalTok{)}\OperatorTok{/}\FloatTok{1e7}\SpecialCharTok{:.2f\}}\SpecialStringTok{ MB on disk"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'0.78 MB on disk'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_pandas }\OperatorTok{=}\NormalTok{ pd.read\_parquet(}\StringTok{\textquotesingle{}data/data.parquet\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8.17 ms ± 3.14 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_polars }\OperatorTok{=}\NormalTok{ pl.read\_parquet(}\StringTok{\textquotesingle{}data/data.parquet\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.51 ms ± 221 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Trying Feather format:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_polars.write\_ipc(}\StringTok{\textquotesingle{}data/data.feather\textquotesingle{}}\NormalTok{)}
\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{os}\SpecialCharTok{.}\NormalTok{path}\SpecialCharTok{.}\NormalTok{getsize(}\StringTok{\textquotesingle{}data/data.feather\textquotesingle{}}\NormalTok{)}\OperatorTok{/}\FloatTok{1e7}\SpecialCharTok{:.2f\}}\SpecialStringTok{ MB on disk"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'0.80 MB on disk'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_polars }\OperatorTok{=}\NormalTok{ pl.read\_ipc(}\StringTok{\textquotesingle{}data/data.feather\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
The slowest run took 5.08 times longer than the fastest. This could mean that an intermediate result is being cached.
173 µs ± 116 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_pandas }\OperatorTok{=}\NormalTok{ pd.read\_feather(}\StringTok{\textquotesingle{}data/data.feather\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.98 ms ± 812 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Trying Lance format: TODO: update once supported.

Trying Pickle format:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pickle}
\NormalTok{pickle.dump(data\_polars, }\BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}data/data.pickle\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}wb\textquotesingle{}}\NormalTok{))}
\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{os}\SpecialCharTok{.}\NormalTok{path}\SpecialCharTok{.}\NormalTok{getsize(}\StringTok{\textquotesingle{}data/data.pickle\textquotesingle{}}\NormalTok{)}\OperatorTok{/}\FloatTok{1e7}\SpecialCharTok{:.2f\}}\SpecialStringTok{ MB on disk"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'0.90 MB on disk'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 data\_polars }\OperatorTok{=}\NormalTok{ pickle.load(}\BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}data/data.pickle\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rb\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
26 ms ± 107 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Things to note:

\begin{itemize}
\tightlist
\item
  The difference in speed is quite large between pandas vs.~polars.
\item
  When dealing with CSV's, the function \texttt{pl.read\_csv} reads in
  parallel, and has better type guessing heuristics.
\item
  The difference in speed is quite large between csv vs.~parquet and
  feather, with feather\textless parquet\textless csv.
\item
  Feather is the fastest, but larger on disk. Thus good for short-term
  storage, and parquet for long-term.
\item
  The fact that pickle isn't the fastest surprised me; but then again,
  it is not optimized for data.
\end{itemize}

\hypertarget{speed-of-join}{%
\subsection{Speed Of Join}\label{speed-of-join}}

Because pandas is built on numpy, people see it as both an in-memory
database, and a matrix/array library. With polars, it is quite clear it
is an in-memory database, and not an array processing library (despite
having a \texttt{pl.dot()} function for inner products). As such, you
cannot multiply two polars dataframes, but you can certainly join then
efficiently.

Make some data:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ make\_data(n\_rows, n\_cols):}
\NormalTok{  data }\OperatorTok{=}\NormalTok{ np.concatenate(}
\NormalTok{  (}
\NormalTok{    np.arange(n\_rows)[:,np.newaxis], }\CommentTok{\# index}
\NormalTok{    np.random.randn(n\_rows,n\_cols), }\CommentTok{\# values}
\NormalTok{    ),}
\NormalTok{    axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
    
  \ControlFlowTok{return}\NormalTok{ data}


\NormalTok{n\_rows }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{n\_cols }\OperatorTok{=} \DecValTok{10}
\NormalTok{data\_left }\OperatorTok{=}\NormalTok{ make\_data(n\_rows, n\_cols)}
\NormalTok{data\_right }\OperatorTok{=}\NormalTok{ make\_data(n\_rows, n\_cols)}
\end{Highlighting}
\end{Shaded}

Polars join:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_left\_polars }\OperatorTok{=}\NormalTok{ pl.DataFrame(data\_left)}
\NormalTok{data\_right\_polars }\OperatorTok{=}\NormalTok{ pl.DataFrame(data\_right)}

\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 polars\_joined }\OperatorTok{=}\NormalTok{ data\_left\_polars.join(data\_right\_polars, on }\OperatorTok{=} \StringTok{\textquotesingle{}column\_0\textquotesingle{}}\NormalTok{, how }\OperatorTok{=} \StringTok{\textquotesingle{}inner\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
66.6 ms ± 5.24 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Pandas join:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_left\_pandas }\OperatorTok{=}\NormalTok{ pd.DataFrame(data\_left)}
\NormalTok{data\_right\_pandas }\OperatorTok{=}\NormalTok{ pd.DataFrame(data\_right)}

\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 pandas\_joined }\OperatorTok{=}\NormalTok{ data\_left\_pandas.merge(data\_right\_pandas, on }\OperatorTok{=} \DecValTok{0}\NormalTok{, how }\OperatorTok{=} \StringTok{\textquotesingle{}inner\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
174 ms ± 9.32 ms per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

\hypertarget{sec-nyc_taxi}{%
\subsection{The NYC Taxi Dataset}\label{sec-nyc_taxi}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OperatorTok{=} \StringTok{\textquotesingle{}data/NYC\textquotesingle{}} \CommentTok{\# Data from https://www.nyc.gov/site/tlc/about/tlc{-}trip{-}record{-}data.page}
\NormalTok{file\_names }\OperatorTok{=}\NormalTok{ os.listdir(path)}
\end{Highlighting}
\end{Shaded}

Pandas query syntax:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%\%}\NormalTok{time }
\NormalTok{taxi\_pandas }\OperatorTok{=}\NormalTok{ pd.read\_parquet(path)}

\NormalTok{query }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\StringTok{    passenger\_count \textgreater{} 0 and }
\StringTok{    passenger\_count \textless{} 5 and  }
\StringTok{    trip\_distance \textgreater{}= 0 and }
\StringTok{    trip\_distance \textless{}= 10 and }
\StringTok{    fare\_amount \textgreater{}= 0 and }
\StringTok{    fare\_amount \textless{}= 100 and }
\StringTok{    tip\_amount \textgreater{}= 0 and }
\StringTok{    tip\_amount \textless{}= 20 and }
\StringTok{    total\_amount \textgreater{}= 0 and }
\StringTok{    total\_amount \textless{}= 100}
\StringTok{    \textquotesingle{}\textquotesingle{}\textquotesingle{}}\NormalTok{.replace(}\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\NormalTok{taxi\_pandas.query(query).groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{).agg(\{}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}mean\textquotesingle{}}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CPU times: user 1.12 s, sys: 1.07 s, total: 2.2 s
Wall time: 1.06 s
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
& tip\_amount \\
passenger\_count & \\
\midrule()
\endhead
1.0 & 2.096363 \\
2.0 & 2.120294 \\
3.0 & 2.074437 \\
4.0 & 2.054331 \\
\bottomrule()
\end{longtable}

Well, the \texttt{loc} syntax is usually faster than the \texttt{query}
syntax:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%\%}\NormalTok{time }
\NormalTok{taxi\_pandas }\OperatorTok{=}\NormalTok{ pd.read\_parquet(path)}

\NormalTok{ind }\OperatorTok{=}\NormalTok{ (}
\NormalTok{    taxi\_pandas[}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{].between(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{) }
    \OperatorTok{\&}\NormalTok{ taxi\_pandas[}\StringTok{\textquotesingle{}trip\_distance\textquotesingle{}}\NormalTok{].between(}\DecValTok{0}\NormalTok{,}\DecValTok{10}\NormalTok{) }
    \OperatorTok{\&}\NormalTok{ taxi\_pandas[}\StringTok{\textquotesingle{}fare\_amount\textquotesingle{}}\NormalTok{].between(}\DecValTok{0}\NormalTok{,}\DecValTok{100}\NormalTok{) }
    \OperatorTok{\&}\NormalTok{ taxi\_pandas[}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{].between(}\DecValTok{0}\NormalTok{,}\DecValTok{20}\NormalTok{) }
    \OperatorTok{\&}\NormalTok{ taxi\_pandas[}\StringTok{\textquotesingle{}total\_amount\textquotesingle{}}\NormalTok{].between(}\DecValTok{0}\NormalTok{,}\DecValTok{100}\NormalTok{)}
\NormalTok{)}
\NormalTok{(}
\NormalTok{    taxi\_pandas[ind]}
\NormalTok{    .groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{)}
\NormalTok{    .agg(\{}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}mean\textquotesingle{}}\NormalTok{\})}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CPU times: user 1.13 s, sys: 948 ms, total: 2.08 s
Wall time: 838 ms
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
& tip\_amount \\
passenger\_count & \\
\midrule()
\endhead
1.0 & 2.096363 \\
2.0 & 2.120294 \\
3.0 & 2.074437 \\
4.0 & 2.054331 \\
\bottomrule()
\end{longtable}

Polars

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%\%}\NormalTok{time }
\NormalTok{q }\OperatorTok{=}\NormalTok{ (}
\NormalTok{    pl.scan\_parquet(}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{path}\SpecialCharTok{\}}\SpecialStringTok{/*.parquet\textquotesingle{}}\NormalTok{)}
\NormalTok{    .}\BuiltInTok{filter}\NormalTok{(}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}trip\_distance\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}trip\_distance\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}=} \DecValTok{10}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}fare\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}fare\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}=} \DecValTok{100}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}=} \DecValTok{20}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}total\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}total\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}=} \DecValTok{100}\NormalTok{)}
\NormalTok{    )}
\NormalTok{    .groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{)}
\NormalTok{    .agg([pl.mean(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{)])}
\NormalTok{    )}
\NormalTok{q.collect()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
CPU times: user 486 ms, sys: 108 ms, total: 594 ms
Wall time: 96.4 ms
\end{verbatim}

\begin{verbatim}
PARTITIONED DS
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
passenger\_count & tip\_amount \\
f64 & f64 \\
\midrule()
\endhead
1.0 & 2.096363 \\
2.0 & 2.120294 \\
4.0 & 2.054331 \\
3.0 & 2.074437 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.show\_graph()}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-41-output-1.svg}

}

\end{figure}

Things to note:

\begin{itemize}
\tightlist
\item
  Pandas \texttt{loc} syntax is faster than \texttt{query}; both
  considerably slower than polars.
\item
  I only have 2 parquet files. When I run the same with more files,
  despite my 16GB of RAM, \textbf{pandas will crash my python kernel}.
\item
  From the query graph I see import is done in parallel, and filtering
  done at scanning time!
\item
  Warning: The \texttt{pl.scan\_paquet()} function will not work with a
  glob if files are in a remote data lake (e.g.~S3). More on that
  later\ldots{}
\end{itemize}

\hypertarget{moving-forward}{%
\subsection{Moving Forward\ldots{}}\label{moving-forward}}

If this motivational section has convinced you to try polars instead of
pandas, here is a more structured intro.

\hypertarget{getting-help}{%
\section{Getting Help}\label{getting-help}}

Before we dive in, you should be aware of the following references for
further help:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A \href{https://github.com/pola-rs/polars}{github page}.
\item
  A
  \href{https://pola-rs.github.io/polars-book/user-guide/index.html}{user
  guide}.
\item
  A very active community on
  \href{https://discord.gg/4UfP5cfBE7}{Discord}.
\item
  The
  \href{https://pola-rs.github.io/polars/py-polars/html/reference/index.html}{API
  reference}.
\item
  A Stack-Overflow
  \href{https://stackoverflow.com/questions/tagged/python-polars}{tag}.
\item
  Cheat-sheet for
  \href{https://www.rhosignal.com/posts/polars-pandas-cheatsheet/}{pandas
  users}.
\end{enumerate}

\textbf{Warning}: Be careful of AI assistants such as Github-Copilot,
TabNine, etc. Polars is still very new, and they may give you pandas
completions instead of polars.

\hypertarget{polars-series}{%
\section{Polars Series}\label{polars-series}}

Much like pandas, polars' fundamental building block is the series. A
series is a column of data, with a name, and a dtype.

\hypertarget{series-object-housekeeping}{%
\subsection{Series-Object
Housekeeping}\label{series-object-housekeeping}}

Construct a series

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{s}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

Make pandas series for comparison:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_pandas }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], name }\OperatorTok{=} \StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
polars.series.series.Series
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(s\_pandas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pandas.core.series.Series
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s\_pandas.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
dtype('int64')
\end{verbatim}

Renaming a series; will be very useful when operating on dataframe
columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.alias(}\StringTok{"b"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
b \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clone()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clone().append(pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
4 \\
5 \\
6 \\
\bottomrule()
\end{longtable}

Note: \texttt{series.append} operates in-place. That is why we cloned
the series first.

Flatten a list of lists using \texttt{explode()}; this will not work for
more than 2 levels of nesting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.Series(}\StringTok{"a"}\NormalTok{, [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{]]).explode()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
4 \\
9 \\
10 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.extend\_constant(}\DecValTok{666}\NormalTok{, n}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
666 \\
666 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rechunk()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rename(}\StringTok{"b"}\NormalTok{, in\_place}\OperatorTok{=}\VariableTok{False}\NormalTok{) }\CommentTok{\# has an in\_place option. Unlike .alias()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
b \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_dummies()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
a\_1 & a\_2 & a\_3 \\
u8 & u8 & u8 \\
\midrule()
\endhead
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clear() }\CommentTok{\# creates an empty series, with same dtype. Previously called s.cleared()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
\bottomrule()
\end{longtable}

Constructing a series of floats, for later use.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\FloatTok{1.}\NormalTok{, }\FloatTok{2.}\NormalTok{, }\FloatTok{3.}\NormalTok{])}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
2.0 \\
3.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

\hypertarget{memory-representation-of-series}{%
\subsection{Memory Representation of
Series}\label{memory-representation-of-series}}

Object size in memory. Super useful for profiling:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.estimated\_size(unit}\OperatorTok{=}\StringTok{"gb"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.2351741790771484e-08
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.chunk\_lengths() }\CommentTok{\# what is the length of each memory chunk?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[3]
\end{verbatim}

\hypertarget{filtering-and-subsetting}{%
\subsection{Filtering and Subsetting}\label{filtering-and-subsetting}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[}\DecValTok{0}\NormalTok{] }\CommentTok{\# same as s.\_\_getitem\_\_(0)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Filtering with \texttt{{[}} and Booleans will not work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[[}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NotImplementedError: Unsupported idxs datatype.
\end{verbatim}

Filtering with a Polars Boolean series, worked in previous versions of
polars (\textless=15). Currently (16) does not.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s[pl.Series(}\StringTok{"a"}\NormalTok{, [}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{])]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ValueError: Cannot __getitem__ on Series of dtype: 'Int64' with argument: 'shape: (3,)
Series: 'a' [bool]
[
    true
    false
    true
]' of type: '<class 'polars.series.series.Series'>'.
\end{verbatim}

Filtering with a pandas (Boolean) series will not work (why should it?),
nor with a numpy array.

For an easy transition to work with lazy dataframes and query planning
(Section~\ref{sec-query-planning}), you may want to prefer the
\texttt{filter} method, which can actually take a polars series, or list
of booleans (but not a pandas series or numpy array):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{filter}\NormalTok{(pl.Series(}\StringTok{"a"}\NormalTok{, [}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{])) }\CommentTok{\# works}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{filter}\NormalTok{([}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.head(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.limit(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.tail(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.sample(}\DecValTok{2}\NormalTok{, with\_replacement}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.take([}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{]) }\CommentTok{\# same as s[0,2] and pandas .iloc[[0,2]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{slice}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{) }\CommentTok{\# same as pandas .iloc[1:2]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.take\_every(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
\bottomrule()
\end{longtable}

\hypertarget{aggregations}{%
\subsection{Aggregations}\label{aggregations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{min}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.arg\_min()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{max}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.arg\_max()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.median()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.entropy()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-4.68213122712422
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
statistic & value \\
str & f64 \\
\midrule()
\endhead
"count" & 3.0 \\
"null\_count" & 0.0 \\
"mean" & 2.0 \\
"std" & 1.0 \\
"min" & 1.0 \\
"max" & 3.0 \\
"median" & 2.0 \\
"25\%" & 1.0 \\
"75\%" & 3.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.value\_counts()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
a & counts \\
i64 & u32 \\
\midrule()
\endhead
1 & 1 \\
2 & 1 \\
3 & 1 \\
\bottomrule()
\end{longtable}

\hypertarget{object-transformations}{%
\subsection{Object Transformations}\label{object-transformations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.Series(}\StringTok{"a"}\NormalTok{,[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]).reshape(dims }\OperatorTok{=}\NormalTok{ (}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
TypeError: reshape() got an unexpected keyword argument 'dims'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shift(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
null \\
1 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shift(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shift\_and\_fill(}\DecValTok{1}\NormalTok{, }\DecValTok{999}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
TypeError: shift_and_fill() takes 2 positional arguments but 3 were given
\end{verbatim}

\hypertarget{mathematical-transformations}{%
\subsection{Mathematical
Transformations}\label{mathematical-transformations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{abs}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.sin()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
0.841471 \\
0.909297 \\
0.14112 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.exp()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
2.718282 \\
7.389056 \\
20.085537 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{hash}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u64 \\
\midrule()
\endhead
6364136223846793005 \\
12728272447693586010 \\
645664597830827398 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.log()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
0.0 \\
0.693147 \\
1.098612 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.peak\_max()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
bool \\
\midrule()
\endhead
false \\
false \\
true \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.sqrt()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
1.414214 \\
1.732051 \\
\bottomrule()
\end{longtable}

\hypertarget{comparisons}{%
\subsection{Comparisons}\label{comparisons}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clip\_max(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clip\_min(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.clip(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{) }\CommentTok{\# AKA Winsorizing}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
2 \\
\bottomrule()
\end{longtable}

You cannot round integers, but you can round floats.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
2.0 \\
3.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.ceil()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
2.0 \\
3.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.floor()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
2.0 \\
3.0 \\
\bottomrule()
\end{longtable}

\hypertarget{search}{%
\subsection{Search}\label{search}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_in(pl.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
false \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_in([}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
false \\
false \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  \texttt{is\_in()} in polars has an underscore, unlike \texttt{isin()}
  in pandas.
\end{itemize}

\hypertarget{apply}{%
\subsection{Apply}\label{apply}}

Applying your own function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: x }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
4 \\
\bottomrule()
\end{longtable}

Using your own functions comes with a performance cost:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=}\NormalTok{ pl.Series(np.random.randn(}\BuiltInTok{int}\NormalTok{(}\FloatTok{1e5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Adding 1 with apply:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 s1.}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: x }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
12.1 ms ± 617 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

Adding 1 without apply:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 s1}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
73.3 µs ± 10 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

\hypertarget{cummulative-operations}{%
\subsection{Cummulative Operations}\label{cummulative-operations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.cummax()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.cumsum()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
3 \\
6 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.cumprod()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
6 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.ewm\_mean(com}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
1.75 \\
2.615385 \\
\bottomrule()
\end{longtable}

\hypertarget{sequential-operations}{%
\subsection{Sequential Operations}\label{sequential-operations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.diff()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
null \\
1 \\
1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.pct\_change()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
null \\
1.0 \\
0.5 \\
\bottomrule()
\end{longtable}

\hypertarget{windowed-operations}{%
\subsection{Windowed Operations}\label{windowed-operations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rolling\_apply(}
\NormalTok{  pl.}\BuiltInTok{sum}\NormalTok{, }
\NormalTok{  window\_size}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
null \\
3 \\
5 \\
\bottomrule()
\end{longtable}

Not all functions will work within a \texttt{rolling\_apply}! Only
polars' functions will.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rolling\_apply(np.}\BuiltInTok{sum}\NormalTok{, window\_size}\OperatorTok{=}\DecValTok{2}\NormalTok{) }\CommentTok{\# will not work}
\end{Highlighting}
\end{Shaded}

Some rolling functions have been prepared for you.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rolling\_max(window\_size}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
null \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\hypertarget{logical-aggregations}{%
\subsection{Logical Aggregations}\label{logical-aggregations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{])}
\NormalTok{b.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Boolean
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b.}\BuiltInTok{all}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b.}\BuiltInTok{any}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\hypertarget{uniques-and-duplicates}{%
\subsection{Uniques and Duplicates}\label{uniques-and-duplicates}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_duplicated()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
false \\
false \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_unique()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
true \\
true \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.n\_unique()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.Series([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{]).unique\_counts()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
2 \\
1 \\
1 \\
1 \\
\bottomrule()
\end{longtable}

The first appearance of a value in a series:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.Series([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{]).is\_first()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
bool \\
\midrule()
\endhead
true \\
true \\
true \\
false \\
\bottomrule()
\end{longtable}

\hypertarget{dtypes}{%
\subsection{dtypes}\label{dtypes}}

\textbf{Note}. Unlike pandas, polars' test functions have an underscore:
\texttt{is\_numeric()} instead of \texttt{isnumeric()}.

\hypertarget{testing}{%
\subsubsection{Testing}\label{testing}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_numeric()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_float()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_utf8()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_boolean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.is\_temporal() }\CommentTok{\# previously called .is\_datelike()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\hypertarget{casting}{%
\subsubsection{Casting}\label{casting}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.cast(pl.Int32)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i32 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  The dtypes to cast to are \textbf{polars} dtypes. Don't try
  \texttt{s.cast("int32")}, \texttt{s.cast(np.int32)}, or
  \texttt{s.cast(pd.int)}
\item
  \texttt{cast()} is polars' equivalent of pandas' \texttt{astype()}.
\item
  For a list of dtypes see the official
  \href{see\%20https://pola-rs.github.io/polars/py-polars/html/reference/datatypes.html}{documentation}.
\end{itemize}

\hypertarget{optimizing-dtypes}{%
\subsubsection{Optimizing dtypes}\label{optimizing-dtypes}}

Find the most efficient dtype for a series:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shrink\_dtype() }\CommentTok{\# like pandas pd.to\_numeric(..., downcast="...") and pandas\_dtype\_efficiency module}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i8 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

Also see
\href{http://braaannigan.github.io/software/2022/10/31/polars-dtype-diet.html}{here}.

Shrink the memory allocation to the size of the actual data (in place).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shrink\_to\_fit() }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\hypertarget{ordering-and-sorting}{%
\subsection{Ordering and Sorting}\label{ordering-and-sorting}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.sort()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.reverse()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
3 \\
2 \\
1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.rank()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f32 \\
\midrule()
\endhead
1.0 \\
2.0 \\
3.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.arg\_sort() }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u32 \\
\midrule()
\endhead
0 \\
1 \\
2 \\
\bottomrule()
\end{longtable}

\texttt{arg\_sort()} returns the indices that would sort the series.
Same as R's \texttt{order()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(s.sort() }\OperatorTok{==}\NormalTok{ s[s.arg\_sort()]).}\BuiltInTok{all}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\texttt{arg\_sort()} can also be used to return the original series from
the sorted one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(s }\OperatorTok{==}\NormalTok{ s[s[s.arg\_sort()].arg\_sort()]).}\BuiltInTok{all}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.shuffle(seed}\OperatorTok{=}\DecValTok{1}\NormalTok{) }\CommentTok{\# random permutation}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
2 \\
1 \\
3 \\
\bottomrule()
\end{longtable}

\hypertarget{missing}{%
\subsection{Missing}\label{missing}}

Pandas users will be excited to know that thanks to arrow, polars has
built in missing value support for all(!) dtypes. This has been a long
awaited feature in the Python data science ecosystem with implications
on speed, memory, style and more. The
\href{https://pola-rs.github.io/polars-book/user-guide/howcani/missing_data.html}{Polars
Userguide} has a great overview of the topic from which we collect some
take-homes:

\begin{itemize}
\tightlist
\item
  \texttt{np.nan} is also supported along \texttt{pl.Null}, but is not
  considered as a missing value by polars. This has implications on null
  counts, statistical aggregations, etc.
\item
  \texttt{pl.Null}, and \texttt{np.nan}s have their own separate
  functions for imputing, counting, etc.
\end{itemize}

PS - Arrow support is also expected in
\href{https://datapythonista.me/blog/pandas-20-and-the-arrow-revolution-part-i}{Pandas
2.0}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\VariableTok{None}\NormalTok{, np.nan])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m.is\_null() }\CommentTok{\# checking for None\textquotesingle{}s. Like pandas .isna()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
false \\
false \\
true \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m.is\_nan() }\CommentTok{\# checking for np.nan\textquotesingle{}s}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
false \\
false \\
null \\
true \\
\bottomrule()
\end{longtable}

For comparison with pandas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_pandas }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\VariableTok{None}\NormalTok{, np.nan])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_pandas.isna()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    False
1    False
2     True
3     True
dtype: bool
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_pandas.isnull() }\CommentTok{\# alias for pd.isna()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    False
1    False
2     True
3     True
dtype: bool
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Polars}
\NormalTok{m1 }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\VariableTok{None}\NormalTok{, }\DecValTok{2}\NormalTok{, ]) }\CommentTok{\# python native None}
\NormalTok{m2 }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, np.nan, }\DecValTok{2}\NormalTok{, ]) }\CommentTok{\# numpy\textquotesingle{}s nan}
\NormalTok{m3 }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}nan\textquotesingle{}}\NormalTok{), }\DecValTok{2}\NormalTok{, ]) }\CommentTok{\# python\textquotesingle{}s nan}

\CommentTok{\# Pandas}
\NormalTok{m4 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\VariableTok{None}\NormalTok{, }\DecValTok{2}\NormalTok{ ])}
\NormalTok{m5 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, np.nan, }\DecValTok{2}\NormalTok{, ])}
\NormalTok{m6 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}nan\textquotesingle{}}\NormalTok{), }\DecValTok{2}\NormalTok{, ])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[m1.}\BuiltInTok{sum}\NormalTok{(), m2.}\BuiltInTok{sum}\NormalTok{(), m3.}\BuiltInTok{sum}\NormalTok{(), m4.}\BuiltInTok{sum}\NormalTok{(), m5.}\BuiltInTok{sum}\NormalTok{(), m6.}\BuiltInTok{sum}\NormalTok{()]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[3, nan, nan, 3.0, 3.0, 3.0]
\end{verbatim}

Things to note:

\begin{itemize}
\tightlist
\item
  Aggregating pandas and polars series behave differently w.r.t. missing
  values:

  \begin{itemize}
  \tightlist
  \item
    Both will ignore \texttt{None}; which is unsafe.
  \item
    Polars will not ignore \texttt{np.nan}; which is safe. Pandas is
    unsafe w.r.t. \texttt{np.nan}, and will ignore it.
  \end{itemize}
\end{itemize}

Filling missing values; \texttt{None} and \texttt{np.nan} are treated
differently:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1.fill\_null(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
0 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2.fill\_null(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
NaN \\
2.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2.fill\_nan(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
0.0 \\
2.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1.drop\_nulls()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1.drop\_nans()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
null \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2.drop\_nulls()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
NaN \\
2.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1.interpolate()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
1 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2.interpolate() }\CommentTok{\# np.nan is not considered missing, so why interpolate?}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
f64 \\
\midrule()
\endhead
1.0 \\
NaN \\
2.0 \\
\bottomrule()
\end{longtable}

\hypertarget{export-to-other-python-objects}{%
\subsection{Export To Other Python
Objects}\label{export-to-other-python-objects}}

The current section deals with exports to other python objects in
memory. See Section~\ref{sec-disk-export} for exporting to disk.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_frame() }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_list()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_numpy() }\CommentTok{\# useful for preparing data for learning with scikit{-}learn}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([1, 2, 3])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_pandas()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    1
1    2
2    3
Name: a, dtype: int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.to\_arrow() }\CommentTok{\# useful for preparing data for learning with XGBoost. Maybe sklearn in the future?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<pyarrow.lib.Int64Array object at 0x290eb0ee0>
[
  1,
  2,
  3
]
\end{verbatim}

\hypertarget{strings}{%
\subsection{Strings}\label{strings}}

Like Pandas, accessed with the \texttt{.str} attribute.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}\StringTok{"foo"}\NormalTok{, }\StringTok{"bar"}\NormalTok{, }\StringTok{"baz"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.n\_chars() }\CommentTok{\# gets number of chars. In ASCII this is the same as lengths()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u32 \\
\midrule()
\endhead
3 \\
3 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.lengths() }\CommentTok{\# gets number of bytes in memory}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u32 \\
\midrule()
\endhead
3 \\
3 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.concat(}\StringTok{"{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"foo-bar-baz" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.contains(}\StringTok{"foo|tra|bar"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
true \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.count\_match(pattern}\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{) }\CommentTok{\# count literal metches}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u32 \\
\midrule()
\endhead
2 \\
0 \\
0 \\
\bottomrule()
\end{longtable}

Regex is supported. The \texttt{r} prefix in
\texttt{r"\textless{}regex\ pattern\textgreater{}"} is useful for
emphasizing regular expressions, but not really necessary (more about it
\href{https://stackoverflow.com/questions/2241600/python-regex-r-prefix}{here}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.count\_match(pattern}\OperatorTok{=}\VerbatimStringTok{r"\textbackslash{}w"}\NormalTok{) }\CommentTok{\# \textbackslash{}w is regex for alphanumeric}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
u32 \\
\midrule()
\endhead
3 \\
3 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.ends\_with(}\StringTok{"oo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
false \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.starts\_with(}\StringTok{"fo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
bool \\
\midrule()
\endhead
true \\
false \\
false \\
\bottomrule()
\end{longtable}

To extract the \textbf{first} appearance of a pattern, use
\texttt{extract}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"a"}\NormalTok{, [}
            \StringTok{"http://vote.com/ballon\_dor?candidate=messi\&ref=polars"}\NormalTok{,}

            \StringTok{"http://vote.com/ballon\_dor?candidate=jorginho\&ref=polars"}\NormalTok{,}

            \StringTok{"http://vote.com/ballon\_dor?candidate=ronaldo\&ref=polars"}
\NormalTok{            ])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url.}\BuiltInTok{str}\NormalTok{.extract(}\VerbatimStringTok{r"=(\textbackslash{}w+)"}\NormalTok{, }\DecValTok{1}\NormalTok{) }\CommentTok{\# "=(\textbackslash{}w+)" is read: match an equality, followed by any number of alphanumerics.}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"messi" \\
"jorginho" \\
"ronaldo" \\
\bottomrule()
\end{longtable}

To extract \textbf{all} appearances of a pattern, use
\texttt{extract\_all}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url.}\BuiltInTok{str}\NormalTok{.extract\_all(}\StringTok{"=(\textbackslash{}w+)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
list{[}str{]} \\
\midrule()
\endhead
{[}"=messi", "=polars"{]} \\
{[}"=jorginho", "=polars"{]} \\
{[}"=ronaldo", "=polars"{]} \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.ljust(}\DecValTok{8}\NormalTok{, }\StringTok{"*"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"foo*****" \\
"bar*****" \\
"baz*****" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.rjust(}\DecValTok{8}\NormalTok{, }\StringTok{"*"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"*****foo" \\
"*****bar" \\
"*****baz" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.lstrip(}\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"oo" \\
"bar" \\
"baz" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.rstrip(}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"foo" \\
"ba" \\
"baz" \\
\bottomrule()
\end{longtable}

Replacing first appearance of a pattern:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.replace(}\VerbatimStringTok{r"o+"}\NormalTok{, }\StringTok{"ZZ"}\NormalTok{)  }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"fZZ" \\
"bar" \\
"baz" \\
\bottomrule()
\end{longtable}

Replace all appearances of a pattern:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.replace\_all(}\StringTok{"o"}\NormalTok{, }\StringTok{"ZZ"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"fZZZZ" \\
"bar" \\
"baz" \\
\bottomrule()
\end{longtable}

String to list of strings. Number of splits inferred.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.split(by}\OperatorTok{=}\StringTok{"o"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
list{[}str{]} \\
\midrule()
\endhead
{[}"f", "", ""{]} \\
{[}"bar"{]} \\
{[}"baz"{]} \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.split(by}\OperatorTok{=}\StringTok{"a"}\NormalTok{, inclusive}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
list{[}str{]} \\
\midrule()
\endhead
{[}"foo"{]} \\
{[}"ba", "r"{]} \\
{[}"ba", "z"{]} \\
\bottomrule()
\end{longtable}

String to dict of strings. Number of \textbf{splits} fixed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.split\_exact(}\StringTok{"a"}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
struct{[}3{]} \\
\midrule()
\endhead
\{"foo",null,null\} \\
\{"b","r",null\} \\
\{"b","z",null\} \\
\bottomrule()
\end{longtable}

String to dict of strings. \textbf{Length of output} fixed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.splitn(}\StringTok{"a"}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
struct{[}4{]} \\
\midrule()
\endhead
\{"foo",null,null,null\} \\
\{"b","r",null,null\} \\
\{"b","z",null,null\} \\
\bottomrule()
\end{longtable}

Strip white spaces.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.Series([}\StringTok{\textquotesingle{}   ohh   \textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}   yeah   \textquotesingle{}}\NormalTok{]).}\BuiltInTok{str}\NormalTok{.strip()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
str \\
\midrule()
\endhead
"ohh" \\
"yeah" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.to\_uppercase()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"FOO" \\
"BAR" \\
"BAZ" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.to\_lowercase()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"foo" \\
"bar" \\
"baz" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.zfill(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"00foo" \\
"00bar" \\
"00baz" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{st.}\BuiltInTok{str}\NormalTok{.}\BuiltInTok{slice}\NormalTok{(offset}\OperatorTok{=}\DecValTok{0}\NormalTok{, length}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
a \\
str \\
\midrule()
\endhead
"fo" \\
"ba" \\
"ba" \\
\bottomrule()
\end{longtable}

\hypertarget{date-and-time}{%
\subsection{Date and Time}\label{date-and-time}}

There are 4 datetime dtypes in polars:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Date: A date, without hours. Generated with \texttt{pl.Date()}.
\item
  Datetime: Date and hours. Generated with \texttt{pl.Datetime()}.
\item
  Time: Hour of day. Generated with \texttt{pl.Time()}.
\item
  Duration: As the name suggests. Similar t o \texttt{timedelta} in
  pandas. Generated with \texttt{pl.Duration()}.
\end{enumerate}

\textbf{Warning}: Python has a sea of modules that support datetimes. A
partial list includes:
\href{https://docs.python.org/3/library/datetime.html}{datetime module},
extensions in
\href{https://dateutil.readthedocs.io/en/stable/}{dateutil},
\href{https://numpy.org/doc/stable/reference/arrays.datetime.html}{numpy},
\href{https://pandas.pydata.org/pandas-docs/version/1.1/user_guide/timeseries.html}{pandas},
\href{https://arrow.readthedocs.io/en/latest/}{arrow}, the deprecated
\href{https://pytseries.sourceforge.net/}{scikits.timeseries} and
certainly others. Be aware of the dtype you are using, and the
accompanying methods.

\hypertarget{time-range}{%
\subsubsection{Time Range}\label{time-range}}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ datetime, timedelta}

\NormalTok{start }\OperatorTok{=}\NormalTok{ datetime(year}\OperatorTok{=} \DecValTok{2001}\NormalTok{, month}\OperatorTok{=}\DecValTok{2}\NormalTok{, day}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\NormalTok{stop }\OperatorTok{=}\NormalTok{ datetime(year}\OperatorTok{=}\DecValTok{2001}\NormalTok{, month}\OperatorTok{=}\DecValTok{2}\NormalTok{, day}\OperatorTok{=}\DecValTok{3}\NormalTok{)}

\NormalTok{date }\OperatorTok{=}\NormalTok{ pl.date\_range(}
\NormalTok{  low}\OperatorTok{=}\NormalTok{start, }
\NormalTok{  high}\OperatorTok{=}\NormalTok{stop, }
\NormalTok{  interval}\OperatorTok{=}\NormalTok{timedelta(seconds}\OperatorTok{=}\DecValTok{500}\OperatorTok{*}\DecValTok{61}\NormalTok{))}
\NormalTok{date}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/2166444983.py:6: DeprecationWarning:

`low` is deprecated as an argument to `date_range`; use `start` instead.

/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/2166444983.py:6: DeprecationWarning:

`high` is deprecated as an argument to `date_range`; use `end` instead.
\end{verbatim}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
datetime{[}μs{]} \\
\midrule()
\endhead
2001-02-02 00:00:00 \\
2001-02-02 08:28:20 \\
2001-02-02 16:56:40 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  How else could I have constructed this series? What other types are
  accepted as \texttt{low} and \texttt{high}?
\item
  \texttt{pl.date\_range} may return a series of dtype \texttt{Date} or
  \texttt{Datetime}. This depens of the granularity of the inputs.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Datetime(time_unit='us', time_zone=None)
\end{verbatim}

Cast to different time unit. May be useful when joining datasets, and
the time unit is different.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.cast\_time\_unit(tu}\OperatorTok{=}\StringTok{"ms"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
TypeError: cast_time_unit() got an unexpected keyword argument 'tu'
\end{verbatim}

\hypertarget{extract-time-sub-units}{%
\subsubsection{Extract Time Sub-Units}\label{extract-time-sub-units}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.second()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
0 \\
20 \\
40 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.minute()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
0 \\
28 \\
56 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.hour()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
0 \\
8 \\
16 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.day()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
2 \\
2 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.week()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
5 \\
5 \\
5 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.weekday()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
5 \\
5 \\
5 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.month()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
2 \\
2 \\
2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.year()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
i32 \\
\midrule()
\endhead
2001 \\
2001 \\
2001 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.ordinal\_day() }\CommentTok{\# day in year}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
33 \\
33 \\
33 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.quarter()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
u32 \\
\midrule()
\endhead
1 \\
1 \\
1 \\
\bottomrule()
\end{longtable}

\hypertarget{durations}{%
\subsubsection{Durations}\label{durations}}

Equivalent to Pandas \texttt{period} dtype.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs }\OperatorTok{=}\NormalTok{ date.diff()}
\NormalTok{diffs}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
duration{[}μs{]} \\
\midrule()
\endhead
null \\
8h 28m 20s \\
8h 28m 20s \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs.dtype}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Duration(time_unit='us')
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs.dt.seconds()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
i64 \\
\midrule()
\endhead
null \\
30500 \\
30500 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs.dt.minutes()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
i64 \\
\midrule()
\endhead
null \\
508 \\
508 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs.dt.days()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
i64 \\
\midrule()
\endhead
null \\
0 \\
0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs.dt.hours()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
i64 \\
\midrule()
\endhead
null \\
8 \\
8 \\
\bottomrule()
\end{longtable}

\hypertarget{date-aggregations}{%
\subsubsection{Date Aggregations}\label{date-aggregations}}

Note that aggregating dates, returns a \texttt{datetime} type object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.}\BuiltInTok{max}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
datetime.datetime(2001, 2, 2, 16, 56, 40)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.}\BuiltInTok{min}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
datetime.datetime(2001, 2, 2, 0, 0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.mean()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
datetime.datetime(2001, 2, 2, 8, 28, 20)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.median()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
datetime.datetime(2001, 2, 2, 8, 28, 20)
\end{verbatim}

\hypertarget{date-transformations}{%
\subsubsection{Date Transformations}\label{date-transformations}}

Notice the syntax of \texttt{offset\_by}. It is similar to R's
\texttt{lubridate} package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.offset\_by(by}\OperatorTok{=}\StringTok{"1y2m20d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
datetime{[}μs{]} \\
\midrule()
\endhead
2002-02-22 00:02:00 \\
2002-02-22 08:30:20 \\
2002-02-22 16:58:40 \\
\bottomrule()
\end{longtable}

Negative offset is also allowed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.offset\_by(by}\OperatorTok{=}\StringTok{"{-}1y2m20d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
datetime{[}μs{]} \\
\midrule()
\endhead
2000-01-12 23:58:00 \\
2000-01-13 08:26:20 \\
2000-01-13 16:54:40 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.}\BuiltInTok{round}\NormalTok{(}\StringTok{"1y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
datetime{[}μs{]} \\
\midrule()
\endhead
2001-01-01 00:00:00 \\
2001-01-01 00:00:00 \\
2001-01-01 00:00:00 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date2 }\OperatorTok{=}\NormalTok{ date.dt.truncate(}\StringTok{"30m"}\NormalTok{) }\CommentTok{\# round to period}
\NormalTok{pd.crosstab(date,date2)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
col\_0 & 2001-02-02 00:00:00 & 2001-02-02 08:00:00 & 2001-02-02
16:30:00 \\
row\_0 & & & \\
\midrule()
\endhead
2001-02-02 00:00:00 & 1 & 0 & 0 \\
2001-02-02 08:28:20 & 0 & 1 & 0 \\
2001-02-02 16:56:40 & 0 & 0 & 1 \\
\bottomrule()
\end{longtable}

\hypertarget{from-date-to-string}{%
\subsubsection{From Date to String}\label{from-date-to-string}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date.dt.strftime(}\StringTok{"\%Y{-}\%m{-}}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
str \\
\midrule()
\endhead
"2001-02-02" \\
"2001-02-02" \\
"2001-02-02" \\
\bottomrule()
\end{longtable}

\hypertarget{from-string-to-datetime}{%
\subsubsection{From String to Datetime}\label{from-string-to-datetime}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd }\OperatorTok{=}\NormalTok{ pl.Series(}
    \StringTok{"date"}\NormalTok{,}
\NormalTok{    [}
        \StringTok{"2021{-}04{-}22"}\NormalTok{,}
        \StringTok{"2022{-}01{-}04 00:00:00"}\NormalTok{,}
        \StringTok{"01/31/22"}\NormalTok{,}
        \StringTok{"Sun Jul  8 00:34:60 2001"}\NormalTok{,}
\NormalTok{    ],}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Parse into \texttt{Date} type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd.}\BuiltInTok{str}\NormalTok{.strptime(datatype}\OperatorTok{=}\NormalTok{ pl.Date, fmt}\OperatorTok{=}\StringTok{"}\SpecialCharTok{\%F}\StringTok{"}\NormalTok{, strict}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/3102708485.py:1: DeprecationWarning:

`datatype` is deprecated as an argument to `strptime`; use `dtype` instead.

/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/3102708485.py:1: DeprecationWarning:

`fmt` is deprecated as an argument to `strptime`; use `format` instead.
\end{verbatim}

\begin{longtable}[]{@{}l@{}}
\toprule()
date \\
date \\
\midrule()
\endhead
2021-04-22 \\
null \\
null \\
null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd.}\BuiltInTok{str}\NormalTok{.strptime(pl.Date, }\StringTok{"\%D"}\NormalTok{, strict}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
date \\
date \\
\midrule()
\endhead
null \\
null \\
2022-01-31 \\
null \\
\bottomrule()
\end{longtable}

Parse into \texttt{Datetime} type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd.}\BuiltInTok{str}\NormalTok{.strptime(pl.Datetime, }\StringTok{"}\SpecialCharTok{\%F}\StringTok{ \%T"}\NormalTok{,strict}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
date \\
datetime{[}μs{]} \\
\midrule()
\endhead
null \\
2022-01-04 00:00:00 \\
null \\
null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd.}\BuiltInTok{str}\NormalTok{.strptime(pl.Datetime, }\StringTok{"\%a \%h }\SpecialCharTok{\%d}\StringTok{ \%T \%Y"}\NormalTok{,strict}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
date \\
datetime{[}μs{]} \\
\midrule()
\endhead
null \\
null \\
null \\
2001-07-08 00:35:00 \\
\bottomrule()
\end{longtable}

Parse into \texttt{Time} type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd.}\BuiltInTok{str}\NormalTok{.strptime(pl.Time, }\StringTok{"\%a \%h }\SpecialCharTok{\%d}\StringTok{ \%T \%Y"}\NormalTok{,strict}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
date \\
time \\
\midrule()
\endhead
null \\
null \\
null \\
00:35:00 \\
\bottomrule()
\end{longtable}

\hypertarget{comparing-series}{%
\subsection{Comparing Series}\label{comparing-series}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s.series\_equal(pl.Series(}\StringTok{"a"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\hypertarget{dataframes}{%
\section{DataFrames}\label{dataframes}}

General:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  There is no row index (like R's \texttt{data.frame},
  \texttt{data.table}, and \texttt{tibble}; unlike Python's
  \texttt{pandas}).
\item
  Will not accept duplicate column names (unlike pandas).
\end{enumerate}

\hypertarget{dataframe-object-hosekeeping}{%
\subsection{DataFrame-Object
Hosekeeping}\label{dataframe-object-hosekeeping}}

A frame can be created as you would expect. From a dictionary of series,
a numpy array, a pandas sdataframe, or a list of polars (or pandas)
series, etc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pl.DataFrame(\{}
  \StringTok{"integer"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }
  \StringTok{"date"}\NormalTok{: [}
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)), }
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)), }
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{))], }
    \StringTok{"float"}\NormalTok{:[}\FloatTok{4.0}\NormalTok{, }\FloatTok{5.0}\NormalTok{, }\FloatTok{6.0}\NormalTok{],}
    \StringTok{"string"}\NormalTok{: [}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{]\})}

\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
└─────────┴─────────────────────┴───────┴────────┘
\end{verbatim}

Things to note:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The frame may be printed with Jupter's styling, or as ASCII with a
  \texttt{print()} statement.
\item
  Shape, and dtypes, are part of the output.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.columns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['integer', 'date', 'float', 'string']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.shape}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(3, 4)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.height }\CommentTok{\# probably more useful than df.shape[0]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.width}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.schema }\CommentTok{\# similar to pandas info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
{'integer': Int64,
 'date': Datetime(time_unit='us', time_zone=None),
 'float': Float64,
 'string': Utf8}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_row\_count()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
row\_nr & integer & date & float & string \\
u32 & i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
0 & 1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
1 & 2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
2 & 3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

Add a single column

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{    pl.Series(}\StringTok{"new"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{    ) }\CommentTok{\# replaces the now{-}deprecated function \textasciigrave{}df.with\_column()\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & new \\
i64 & datetime{[}μs{]} & f64 & str & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 2 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 3 \\
\bottomrule()
\end{longtable}

Add multiple columns

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{  pl.Series(}\StringTok{"new1"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]),}
\NormalTok{  pl.Series(}\StringTok{"new2"}\NormalTok{, [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllll@{}}
\toprule()
integer & date & float & string & new1 & new2 \\
i64 & datetime{[}μs{]} & f64 & str & i64 & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 & 4 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 2 & 5 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 3 & 6 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.clone() }\CommentTok{\# deep copy}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

The following commands make changes in place; I am thus creating a copy
of \texttt{df}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_copy }\OperatorTok{=}\NormalTok{ df.clone() }\CommentTok{\# making a copy since }
\NormalTok{df\_copy.insert\_at\_idx(}\DecValTok{1}\NormalTok{, pl.Series(}\StringTok{"new"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])) }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & new & date & float & string \\
i64 & i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_copy.replace\_at\_idx(}\DecValTok{0}\NormalTok{, pl.Series(}\StringTok{"new2"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
new2 & new & date & float & string \\
i64 & i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_copy.replace(}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, pl.Series(}\StringTok{"new\_float"}\NormalTok{, [}\FloatTok{4.0}\NormalTok{, }\FloatTok{5.0}\NormalTok{, }\FloatTok{6.0}\NormalTok{])) }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
new2 & new & date & float & string \\
i64 & i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ foo(frame):}
  \ControlFlowTok{return}\NormalTok{ frame.with\_columns(pl.Series(}\StringTok{"new"}\NormalTok{, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))}
\NormalTok{df.pipe(foo)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & new \\
i64 & datetime{[}μs{]} & f64 & str & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 2 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.is\_empty()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.clear() }\CommentTok{\# make empty copy. replaced .cleared()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.clear().is\_empty()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rename(\{}\StringTok{\textquotesingle{}integer\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}integer2\textquotesingle{}}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer2 & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\hypertarget{convert-to-other-python-objects}{%
\subsection{Convert to Other Python
Objects}\label{convert-to-other-python-objects}}

\hypertarget{to-pandas}{%
\subsubsection{To Pandas}\label{to-pandas}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.to\_pandas()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
& integer & date & float & string \\
\midrule()
\endhead
0 & 1 & 2022-01-01 & 4.0 & a \\
1 & 2 & 2022-01-02 & 5.0 & b \\
2 & 3 & 2022-01-03 & 6.0 & c \\
\bottomrule()
\end{longtable}

\hypertarget{to-numpy}{%
\subsubsection{To Numpy}\label{to-numpy}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.to\_numpy()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[1, datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'],
       [2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'],
       [3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c']], dtype=object)
\end{verbatim}

\hypertarget{to-list}{%
\subsubsection{To List}\label{to-list}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.get\_columns() }\CommentTok{\# columns as list of polars series}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[shape: (3,)
 Series: 'integer' [i64]
 [
    1
    2
    3
 ],
 shape: (3,)
 Series: 'date' [datetime[μs]]
 [
    2022-01-01 00:00:00
    2022-01-02 00:00:00
    2022-01-03 00:00:00
 ],
 shape: (3,)
 Series: 'float' [f64]
 [
    4.0
    5.0
    6.0
 ],
 shape: (3,)
 Series: 'string' [str]
 [
    "a"
    "b"
    "c"
 ]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rows() }\CommentTok{\# rows as list of tuples}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[(1, datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'),
 (2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'),
 (3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c')]
\end{verbatim}

\hypertarget{to-python-dict}{%
\subsubsection{To Python Dict}\label{to-python-dict}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.to\_dict() }\CommentTok{\# columns as dict of polars series}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
{'integer': shape: (3,)
 Series: 'integer' [i64]
 [
    1
    2
    3
 ],
 'date': shape: (3,)
 Series: 'date' [datetime[μs]]
 [
    2022-01-01 00:00:00
    2022-01-02 00:00:00
    2022-01-03 00:00:00
 ],
 'float': shape: (3,)
 Series: 'float' [f64]
 [
    4.0
    5.0
    6.0
 ],
 'string': shape: (3,)
 Series: 'string' [str]
 [
    "a"
    "b"
    "c"
 ]}
\end{verbatim}

\hypertarget{dataframe-in-memory}{%
\subsection{Dataframe in Memory}\label{dataframe-in-memory}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.estimated\_size(unit}\OperatorTok{=}\StringTok{"gb"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9.96515154838562e-08
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.n\_chunks() }\CommentTok{\# number of ChunkedArrays in the dataframe}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rechunk() }\CommentTok{\# ensure contiguous memory layout}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.shrink\_to\_fit() }\CommentTok{\# reduce memory allocation to actual size}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\hypertarget{statistical-aggregations}{%
\subsection{Statistical Aggregations}\label{statistical-aggregations}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
describe & integer & date & float & string \\
str & f64 & str & f64 & str \\
\midrule()
\endhead
"count" & 3.0 & "3" & 3.0 & "3" \\
"null\_count" & 0.0 & "0" & 0.0 & "0" \\
"mean" & 2.0 & null & 5.0 & null \\
"std" & 1.0 & null & 1.0 & null \\
"min" & 1.0 & "2022-01-01 00:\ldots{} & 4.0 & "a" \\
"max" & 3.0 & "2022-01-03 00:\ldots{} & 6.0 & "c" \\
"median" & 2.0 & null & 5.0 & null \\
"25\%" & 1.0 & null & 4.0 & null \\
"75\%" & 3.0 & null & 6.0 & null \\
\bottomrule()
\end{longtable}

Compare to pandas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.to\_pandas().describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
& integer & date & float \\
\midrule()
\endhead
count & 3.0 & 3 & 3.0 \\
mean & 2.0 & 2022-01-02 00:00:00 & 5.0 \\
min & 1.0 & 2022-01-01 00:00:00 & 4.0 \\
25\% & 1.5 & 2022-01-01 12:00:00 & 4.5 \\
50\% & 2.0 & 2022-01-02 00:00:00 & 5.0 \\
75\% & 2.5 & 2022-01-02 12:00:00 & 5.5 \\
max & 3.0 & 2022-01-03 00:00:00 & 6.0 \\
std & 1.0 & NaN & 1.0 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  Comparing to pandas:

  \begin{itemize}
  \tightlist
  \item
    Polars will summarize all columns even if they are not numeric.
  \item
    The statistics returned are different.
  \end{itemize}
\end{itemize}

Statistical aggregations operate column-wise (and in parallel).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.}\BuiltInTok{max}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.}\BuiltInTok{min}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.mean()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
f64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2.0 & null & 5.0 & null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.median()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
f64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2.0 & null & 5.0 & null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
6 & null & 15.0 & null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.std()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
f64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1.0 & null & 1.0 & null \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.quantile(}\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
f64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1.0 & null & 4.0 & null \\
\bottomrule()
\end{longtable}

\hypertarget{extraction}{%
\subsection{Extraction}\label{extraction}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  If you are used to pandas, recall there is no index. There is thus no
  need for \texttt{loc} vs.~\texttt{iloc}, \texttt{reset\_index()}, etc.
  See
  \href{https://pola-rs.github.io/polars-book/user-guide/howcani/selecting_data/selecting_data_indexing.html}{here}
  for a comparison of extractors between polars and pandas.
\item
  Filtering and selection is possible with the \texttt{{[}} operator, or
  the \texttt{filter()} and \texttt{select()} methods. The latter is
  recommended to facilitate query planning (discussed in
  Section~\ref{sec-query-planning}).
\end{enumerate}

Single cell extraction.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{] }\CommentTok{\# like pandas .iloc[]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Slicing along rows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{0}\NormalTok{:}\DecValTok{1}\NormalTok{] }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
\bottomrule()
\end{longtable}

Slicing along columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[:,}\DecValTok{0}\NormalTok{:}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\hypertarget{selecting-columns}{%
\subsubsection{Selecting Columns}\label{selecting-columns}}

Column selection by label

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(}\StringTok{"integer"}\NormalTok{)}
\CommentTok{\# or df[\textquotesingle{}integer\textquotesingle{}]}
\CommentTok{\# or df[:,\textquotesingle{}integer\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

Select columns with list of labels

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select([}\StringTok{"integer"}\NormalTok{, }\StringTok{"float"}\NormalTok{])}
\CommentTok{\# or df[[\textquotesingle{}integer\textquotesingle{}, \textquotesingle{}float\textquotesingle{}]]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
integer & float \\
i64 & f64 \\
\midrule()
\endhead
1 & 4.0 \\
2 & 5.0 \\
3 & 6.0 \\
\bottomrule()
\end{longtable}

As of polars\textgreater=15.0.0, you don't have to pass a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(}\StringTok{"integer"}\NormalTok{, }\StringTok{"float"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
integer & float \\
i64 & f64 \\
\midrule()
\endhead
1 & 4.0 \\
2 & 5.0 \\
3 & 6.0 \\
\bottomrule()
\end{longtable}

Column slicing by label

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[:,}\StringTok{"integer"}\NormalTok{:}\StringTok{"float"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
integer & date & float \\
i64 & datetime{[}μs{]} & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 \\
2 & 2022-01-02 00:00:00 & 5.0 \\
3 & 2022-01-03 00:00:00 & 6.0 \\
\bottomrule()
\end{longtable}

Note: \texttt{df.select()} does not support slicing ranges such as
\texttt{df.select("integer":"float")}.

Get a column as a 1D polars frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.get\_column(}\StringTok{\textquotesingle{}integer\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

Get a column as a polars series.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.to\_series(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.find\_idx\_by\_name(}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.drop(}\StringTok{"integer"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
date & float & string \\
datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2022-01-01 00:00:00 & 4.0 & "a" \\
2022-01-02 00:00:00 & 5.0 & "b" \\
2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\texttt{df.drop()} not have an \texttt{inplace} argument. Use
\texttt{df.drop\_in\_place()} instead.

\hypertarget{pl.col}{%
\subsubsection{pl.col()}\label{pl.col}}

The \texttt{pl.col()} is \textbf{super important} for referencing
columns. It will be used to select columns within a \texttt{df.select()}
context, and to transform columns within a \texttt{df.with\_columns()}
context. It may extract a single column, a list, a particular (polars)
dtype, a regex pattern, or simply all columns.

When exctracting along dtype, use polars' dtypes, not pandas' dtypes.
For example, use \texttt{pl.Int64} instead of \texttt{np.int64}.

Select along dtype

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(pl.Int64))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
1 \\
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(pl.Float64))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
float \\
f64 \\
\midrule()
\endhead
4.0 \\
5.0 \\
6.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(pl.Utf8))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
string \\
str \\
\midrule()
\endhead
"a" \\
"b" \\
"c" \\
\bottomrule()
\end{longtable}

List of dtypes

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col([pl.Int64, pl.Float64]))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
integer & float \\
i64 & f64 \\
\midrule()
\endhead
1 & 4.0 \\
2 & 5.0 \\
3 & 6.0 \\
\bottomrule()
\end{longtable}

Regular Expression

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(}\StringTok{"*"}\NormalTok{)) }\CommentTok{\# same as df.select(pl.all())}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(}\StringTok{"*"}\NormalTok{).exclude(}\StringTok{"integer"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
date & float & string \\
datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2022-01-01 00:00:00 & 4.0 & "a" \\
2022-01-02 00:00:00 & 5.0 & "b" \\
2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(}\StringTok{"*"}\NormalTok{).exclude(pl.Float64))}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
integer & date & string \\
i64 & datetime{[}μs{]} & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & "a" \\
2 & 2022-01-02 00:00:00 & "b" \\
3 & 2022-01-03 00:00:00 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select(pl.col(}\StringTok{"\^{}.*te.*$"}\NormalTok{)) }\CommentTok{\# regex matching anything with a "te"}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
integer & date \\
i64 & datetime{[}μs{]} \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 \\
2 & 2022-01-02 00:00:00 \\
3 & 2022-01-03 00:00:00 \\
\bottomrule()
\end{longtable}

\hypertarget{filtering-rows}{%
\subsubsection{Filtering Rows}\label{filtering-rows}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.head(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.limit(}\DecValTok{2}\NormalTok{) }\CommentTok{\# same as pl.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.tail(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.take\_every(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.}\BuiltInTok{slice}\NormalTok{(offset}\OperatorTok{=}\DecValTok{1}\NormalTok{, length}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.sample(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.row(}\DecValTok{1}\NormalTok{) }\CommentTok{\# get row as tuple}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b')
\end{verbatim}

Row filtering by label

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"integer"}\NormalTok{) }\OperatorTok{==} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  The \texttt{{[}} operator does not support indexing with boolean such
  as \texttt{df{[}df{[}"integer"{]}\ ==\ 2{]}}.
\item
  The \texttt{filter()} method is recommended over \texttt{{[}} by the
  authors of polars, to facilitate lazy evaluation (discussed later).
\end{itemize}

\hypertarget{selecting-a-single-item}{%
\subsubsection{Selecting A Single Item}\label{selecting-a-single-item}}

Exctracts the first element as a scalar. Useful when you output a single
number as a frame object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.DataFrame([}\DecValTok{1}\NormalTok{]).item() }\CommentTok{\# notice the output is not a frame, rather, a scalar.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\hypertarget{uniques-and-duplicates-1}{%
\subsection{Uniques and Duplicates}\label{uniques-and-duplicates-1}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.is\_unique()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
bool \\
\midrule()
\endhead
true \\
true \\
true \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.is\_duplicated()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
 \\
bool \\
\midrule()
\endhead
false \\
false \\
false \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.unique() }\CommentTok{\# same as pd.drop\_duplicates()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.n\_unique()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\hypertarget{missing-1}{%
\subsection{Missing}\label{missing-1}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls }\OperatorTok{=}\NormalTok{ df.with\_columns(}
\NormalTok{    pl.Series(}\StringTok{"missing"}\NormalTok{, [}\DecValTok{3}\NormalTok{, }\VariableTok{None}\NormalTok{, np.nan]),}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls.null\_count() }\CommentTok{\# same as pd.isnull().sum()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & missing \\
u32 & u32 & u32 & u32 & u32 \\
\midrule()
\endhead
0 & 0 & 0 & 0 & 1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls.drop\_nulls() }\CommentTok{\# same as pd.dropna()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & missing \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 3.0 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & NaN \\
\bottomrule()
\end{longtable}

\textbf{Note}: There is no \texttt{drop\_nan()} method. See
\href{https://stackoverflow.com/questions/75548444/polars-dataframe-drop-nans}{here}
for workarounds.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls.fill\_null(}\DecValTok{0}\NormalTok{) }\CommentTok{\# same as pd.fillna(0)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & missing \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 3.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 0.0 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & NaN \\
\bottomrule()
\end{longtable}

But recall that \texttt{None} and \texttt{np.nan} are not the same
thing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls.fill\_nan(}\DecValTok{99}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & missing \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 3.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & null \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 99.0 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_with\_nulls.interpolate()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & missing \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 3.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & NaN \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & NaN \\
\bottomrule()
\end{longtable}

\hypertarget{transformations}{%
\subsection{Transformations}\label{transformations}}

\begin{itemize}
\tightlist
\item
  The general idea of colum trasformation is to wrap all transformations
  in a \texttt{with\_columns()} method, and the select colums to operat
  on with \texttt{pl.col()}.
\item
  Previous versions of polars used \texttt{df.with\_column()} and
  \texttt{df.with\_columns()}. The \texttt{with\_column()} method is now
  deprecated.
\item
  The output column will have the same name as the input, unless you use
  the \texttt{alias()} method to rename it.
\item
  The \texttt{with\_columns()} is called a \textbf{polars context}.
\item
  The flavor of the \texttt{with\_columns()} context is similar to
  pandas' \texttt{assign()}.
\item
  One can use \texttt{df.iter\_rows()} to get an iterator over rows.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{    pl.col(}\StringTok{"integer"}\NormalTok{) }\OperatorTok{*} \DecValTok{2}\NormalTok{,}
\NormalTok{    pl.col(}\StringTok{"integer"}\NormalTok{).alias(}\StringTok{"integer2"}\NormalTok{),}
\NormalTok{    integer3 }\OperatorTok{=}\NormalTok{ pl.col(}\StringTok{"integer"}\NormalTok{) }\OperatorTok{*} \DecValTok{3}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllll@{}}
\toprule()
integer & date & float & string & integer2 & integer3 \\
i64 & datetime{[}μs{]} & f64 & str & i64 & i64 \\
\midrule()
\endhead
2 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 & 3 \\
4 & 2022-01-02 00:00:00 & 5.0 & "b" & 2 & 6 \\
6 & 2022-01-03 00:00:00 & 6.0 & "c" & 3 & 9 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  The columns \texttt{integer} is multiplied by 2 in place, because no
  \texttt{alias} is used.
\item
  The column \texttt{integer} is copied, by renaming it to
  \texttt{integer2}.
\item
  As of polars version \textgreater15.\emph{.} (I think), you can use
  \texttt{=} to assign. That is how \texttt{integer3} is created.
\item
  You cannot use \texttt{{[}} to assign! This would not have worked
  \texttt{df{[}\textquotesingle{}integer3\textquotesingle{}{]}\ =\ df{[}\textquotesingle{}integer\textquotesingle{}{]}\ *\ 2}
\end{itemize}

If a selection returns multiple columns, all will be transformed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{    pl.col([pl.Int64,pl.Float64])}\OperatorTok{*}\DecValTok{2}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2 & 2022-01-01 00:00:00 & 8.0 & "a" \\
4 & 2022-01-02 00:00:00 & 10.0 & "b" \\
6 & 2022-01-03 00:00:00 & 12.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{    pl.}\BuiltInTok{all}\NormalTok{().cast(pl.Utf8)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
str & str & str & str \\
\midrule()
\endhead
"1" & "2022-01-01 00:\ldots{} & "4.0" & "a" \\
"2" & "2022-01-02 00:\ldots{} & "5.0" & "b" \\
"3" & "2022-01-03 00:\ldots{} & "6.0" & "c" \\
\bottomrule()
\end{longtable}

Apply your own lambda function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.select([pl.col(}\StringTok{"integer"}\NormalTok{), pl.col(}\StringTok{"float"}\NormalTok{)]).}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: x[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ x[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
apply \\
f64 \\
\midrule()
\endhead
5.0 \\
7.0 \\
9.0 \\
\bottomrule()
\end{longtable}

As usual, using your own functions may have a very serious toll on
performance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_big }\OperatorTok{=}\NormalTok{ pl.DataFrame(np.random.randn(}\DecValTok{1000000}\NormalTok{, }\DecValTok{2}\NormalTok{), schema}\OperatorTok{=}\NormalTok{[}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{]) }\CommentTok{\# previous versions used columns= instead of schema=}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 df\_big.}\BuiltInTok{sum}\NormalTok{(axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
683 µs ± 357 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\%}\NormalTok{timeit }\OperatorTok{{-}}\NormalTok{n2 }\OperatorTok{{-}}\NormalTok{r2 df\_big.}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: x[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ x[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
218 ms ± 448 µs per loop (mean ± std. dev. of 2 runs, 2 loops each)
\end{verbatim}

How would numpy and pandas deal with this row-wise summation?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.shift(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
null & null & null & null \\
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.shift\_and\_fill(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}WOW\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
TypeError: shift_and_fill() takes 2 positional arguments but 3 were given
\end{verbatim}

\hypertarget{sorting}{%
\subsection{Sorting}\label{sorting}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.sort(by}\OperatorTok{=}\NormalTok{[}\StringTok{"integer"}\NormalTok{,}\StringTok{"float"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.reverse()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
\bottomrule()
\end{longtable}

\hypertarget{sec-joins}{%
\subsection{Joins}\label{sec-joins}}

High level:

\begin{itemize}
\tightlist
\item
  \texttt{df.hstack()} for horizontal concatenation; like pandas
  \texttt{pd.concat({[}{]},axis=1)} or R's \texttt{cbind}.
\item
  \texttt{df.vstack()} for vertical concatenation; like pandas
  \texttt{pd.concat({[}{]},axis=0)} or R's \texttt{rbind}.
\item
  \texttt{df.merge\_sorted()} for vertical stacking, with sorting.
\item
  \texttt{pl.concat()}, which is similar to the previous two, but with
  memory re-chunking. \texttt{pl.concat()} also allows diagonal
  concatenation, if columns are not shared.
\item
  \texttt{df.extend()} for vertical concatenation, but with memory
  re-chunking. Similar to \texttt{df.vstack().rechunk()}.
\item
  \texttt{df.join()} for joins; like pandas \texttt{pd.merge()} or
  \texttt{df.join()}.
\end{itemize}

For more on the differences between these methods, see
\href{https://www.rhosignal.com/posts/polars-extend-vstack/}{here}.

\hypertarget{hstack}{%
\subsubsection{hstack}\label{hstack}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_column }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"c"}\NormalTok{, np.repeat(}\DecValTok{1}\NormalTok{, df.height))}

\NormalTok{df.hstack([new\_column])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & c \\
i64 & datetime{[}μs{]} & f64 & str & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 1 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 1 \\
\bottomrule()
\end{longtable}

\hypertarget{vstack}{%
\subsubsection{vstack}\label{vstack}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df2 }\OperatorTok{=}\NormalTok{ pl.DataFrame(\{}
  \StringTok{"integer"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }
  \StringTok{"date"}\NormalTok{: [}
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)), }
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)), }
\NormalTok{    (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{))], }
    \StringTok{"float"}\NormalTok{:[}\FloatTok{7.0}\NormalTok{, }\FloatTok{8.0}\NormalTok{, }\FloatTok{9.0}\NormalTok{],}
    \StringTok{"string"}\NormalTok{: [}\StringTok{"d"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"d"}\NormalTok{]\})}


\NormalTok{df.vstack(df2)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

\hypertarget{concatenation}{%
\subsubsection{Concatenation}\label{concatenation}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.concat([df, df2]) }
\CommentTok{\# equivalent to:}
\CommentTok{\# pl.concat([df, df2], how=\textquotesingle{}vertical\textquotesingle{}, rechunk=True, parallel=True) }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.concat([df,new\_column.to\_frame()], how}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & c \\
i64 & datetime{[}μs{]} & f64 & str & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 1 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 1 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 1 \\
\bottomrule()
\end{longtable}

\hypertarget{extend}{%
\subsubsection{extend}\label{extend}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.extend(df2) }\CommentTok{\# like vstack, but with memory re{-}chunking. Similar to df.vstack().rechunk()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

\hypertarget{merge_sorted}{%
\subsubsection{merge\_sorted}\label{merge_sorted}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.merge\_sorted(df2, key}\OperatorTok{=}\StringTok{"integer"}\NormalTok{) }\CommentTok{\# vstacking with sorting.}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

\textbf{Caution}: Joining along rows is possible only if matched columns
have the same dtype. Timestamps may be tricky because they may have
different time units. Recall that timeunits may be cast before joining
using \texttt{series.dt.cast\_time\_unit()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{    pl.col(pl.Datetime(}\StringTok{"ns"}\NormalTok{)).dt.cast\_time\_unit(tu}\OperatorTok{=}\StringTok{"ms"}\NormalTok{)}
\NormalTok{)            }
\end{Highlighting}
\end{Shaded}

If you cannot arrange schema before concatenating, use a diagonal
concatenation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.concat(}
\NormalTok{    [df,new\_column.to\_frame()], }
\NormalTok{    how}\OperatorTok{=}\StringTok{\textquotesingle{}diagonal\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & c \\
i64 & datetime{[}μs{]} & f64 & str & i64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & null \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & null \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & null \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & null \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & null \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" & null \\
null & null & null & null & 1 \\
null & null & null & null & 1 \\
null & null & null & null & 1 \\
\bottomrule()
\end{longtable}

\hypertarget{join}{%
\subsubsection{join}\label{join}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.join(df2, on}\OperatorTok{=}\StringTok{"integer"}\NormalTok{, how}\OperatorTok{=}\StringTok{"left"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule()
integer & date & float & string & date\_right & float\_right &
string\_right \\
i64 & datetime{[}μs{]} & f64 & str & datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 2022-01-06 00:00:00 & 9.0 & "d" \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & 2022-01-04 00:00:00 & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & 2022-01-05 00:00:00 & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" & 2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  Repeating column names have been suffixed with ``\_right''.
\item
  Unlike pandas, there are no indices. The
  \texttt{on}/\texttt{left\_on}/\texttt{right\_on} argument is always
  required.
\item
  \texttt{how=} may take the following values: `inner', `left', `outer',
  `semi', `anti', `cross'.
\item
  The join is super fast, as demonstrated in
  Section~\ref{sec-motivation} above.
\end{itemize}

\hypertarget{join_asof}{%
\subsubsection{join\_asof}\label{join_asof}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.join\_asof(}
\NormalTok{    df2, }
\NormalTok{    left\_on}\OperatorTok{=}\StringTok{"date"}\NormalTok{, }
\NormalTok{    right\_on}\OperatorTok{=}\StringTok{\textquotesingle{}date\textquotesingle{}}\NormalTok{, }
\NormalTok{    by}\OperatorTok{=}\StringTok{"integer"}\NormalTok{, }
\NormalTok{    strategy}\OperatorTok{=}\StringTok{"backward"}\NormalTok{, }
\NormalTok{    tolerance}\OperatorTok{=}\StringTok{\textquotesingle{}1w\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
argument in operation 'asof_join' is not explicitly sorted

- If your data is ALREADY sorted, set the sorted flag with: '.set_sorted()'.
- If your data is NOT sorted, sort the 'expr/series/column' first.

This might become an error in a future version.
    
argument in operation 'asof_join' is not explicitly sorted

- If your data is ALREADY sorted, set the sorted flag with: '.set_sorted()'.
- If your data is NOT sorted, sort the 'expr/series/column' first.

This might become an error in a future version.
    
\end{verbatim}

\begin{longtable}[]{@{}llllll@{}}
\toprule()
integer & date & float & string & float\_right & string\_right \\
i64 & datetime{[}μs{]} & f64 & str & f64 & str \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & null & null \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & null & null \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & null & null \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & 7.0 & "d" \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & 8.0 & "d" \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" & 9.0 & "d" \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  Yes! \texttt{merge\_asof()} is also available.
\item
  The \texttt{strategy=} argument may take the following values:
  `backward', `forward'.
\item
  The \texttt{tolerance=} argument may take the following values: `1w',
  `1d', `1h', `1m', `1s', `1ms', `1us', `1ns'.
\end{itemize}

\hypertarget{reshaping}{%
\subsection{Reshaping}\label{reshaping}}

High level:

\begin{itemize}
\tightlist
\item
  \texttt{df.transpose()} as the name suggests.
\item
  \texttt{df.melt()} for wide to long.
\item
  \texttt{df.pivot()} for long to wide.
\item
  \texttt{df.explode()} for breaking strings into rows.
\item
  \texttt{df.unstack()}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.transpose()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllll@{}}
\toprule()
column\_0 & column\_1 & column\_2 & column\_3 & column\_4 & column\_5 \\
str & str & str & str & str & str \\
\midrule()
\endhead
"1" & "2" & "3" & "1" & "2" & "3" \\
"2022-01-01 00:\ldots{} & "2022-01-02 00:\ldots{} & "2022-01-03
00:\ldots{} & "2022-01-04 00:\ldots{} & "2022-01-05 00:\ldots{} &
"2022-01-06 00:\ldots{} \\
"4.0" & "5.0" & "6.0" & "7.0" & "8.0" & "9.0" \\
"a" & "b" & "c" & "d" & "d" & "d" \\
\bottomrule()
\end{longtable}

\hypertarget{wide-to-long}{%
\subsubsection{Wide to Long}\label{wide-to-long}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# The following example is adapted from Pandas documentation: https://pandas.pydata.org/docs/reference/api/pandas.wide\_to\_long.html}

\NormalTok{np.random.seed(}\DecValTok{123}\NormalTok{)}
\NormalTok{wide }\OperatorTok{=}\NormalTok{ pl.DataFrame(\{}
    \StringTok{\textquotesingle{}famid\textquotesingle{}}\NormalTok{: [}\StringTok{"11"}\NormalTok{, }\StringTok{"12"}\NormalTok{, }\StringTok{"13"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"3"}\NormalTok{, }\StringTok{"3"}\NormalTok{, }\StringTok{"3"}\NormalTok{],}
    \StringTok{\textquotesingle{}birth\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{],}
    \StringTok{\textquotesingle{}ht1\textquotesingle{}}\NormalTok{: [}\FloatTok{2.8}\NormalTok{, }\FloatTok{2.9}\NormalTok{, }\FloatTok{2.2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FloatTok{1.8}\NormalTok{, }\FloatTok{1.9}\NormalTok{, }\FloatTok{2.2}\NormalTok{, }\FloatTok{2.3}\NormalTok{, }\FloatTok{2.1}\NormalTok{],}
    \StringTok{\textquotesingle{}ht2\textquotesingle{}}\NormalTok{: [}\FloatTok{3.4}\NormalTok{, }\FloatTok{3.8}\NormalTok{, }\FloatTok{2.9}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\FloatTok{2.8}\NormalTok{, }\FloatTok{2.4}\NormalTok{, }\FloatTok{3.3}\NormalTok{, }\FloatTok{3.4}\NormalTok{, }\FloatTok{2.9}\NormalTok{]\})}

\NormalTok{wide.head(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
famid & birth & ht1 & ht2 \\
str & i64 & f64 & f64 \\
\midrule()
\endhead
"11" & 1 & 2.8 & 3.4 \\
"12" & 2 & 2.9 & 3.8 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wide.melt(}
\NormalTok{  id\_vars}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}famid\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}birth\textquotesingle{}}\NormalTok{], }
\NormalTok{  value\_vars}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}ht1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}ht2\textquotesingle{}}\NormalTok{], }
\NormalTok{  variable\_name}\OperatorTok{=}\StringTok{\textquotesingle{}treatment\textquotesingle{}}\NormalTok{, }
\NormalTok{  value\_name}\OperatorTok{=}\StringTok{\textquotesingle{}height\textquotesingle{}}\NormalTok{).sample(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
famid & birth & treatment & height \\
str & i64 & str & f64 \\
\midrule()
\endhead
"3" & 3 & "ht2" & 2.9 \\
"3" & 2 & "ht1" & 2.3 \\
"2" & 1 & "ht2" & 3.2 \\
"3" & 3 & "ht1" & 2.1 \\
"2" & 3 & "ht2" & 2.4 \\
\bottomrule()
\end{longtable}

Break strings into rows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wide.explode(columns}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}famid\textquotesingle{}}\NormalTok{]).limit(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
famid & birth & ht1 & ht2 \\
str & i64 & f64 & f64 \\
\midrule()
\endhead
"1" & 1 & 2.8 & 3.4 \\
"1" & 1 & 2.8 & 3.4 \\
"1" & 2 & 2.9 & 3.8 \\
"2" & 2 & 2.9 & 3.8 \\
"1" & 3 & 2.2 & 2.9 \\
\bottomrule()
\end{longtable}

\hypertarget{long-to-wide}{%
\subsubsection{Long to Wide}\label{long-to-wide}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example adapted from https://stackoverflow.com/questions/5890584/how{-}to{-}reshape{-}data{-}from{-}long{-}to{-}wide{-}format}

\BuiltInTok{long} \OperatorTok{=}\NormalTok{ pl.DataFrame(\{}
    \StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{],}
    \StringTok{\textquotesingle{}treatment\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}height\textquotesingle{}}\NormalTok{: [}\FloatTok{2.8}\NormalTok{, }\FloatTok{2.9}\NormalTok{, }\FloatTok{2.2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FloatTok{1.8}\NormalTok{, }\FloatTok{1.9}\NormalTok{, }\FloatTok{2.2}\NormalTok{, }\FloatTok{2.3}\NormalTok{, }\FloatTok{2.1}\NormalTok{]}
\NormalTok{    \})}
  
\BuiltInTok{long}\NormalTok{.limit(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule()
id & treatment & height \\
i64 & str & f64 \\
\midrule()
\endhead
1 & "A" & 2.8 \\
1 & "A" & 2.9 \\
1 & "B" & 2.2 \\
2 & "A" & 2.0 \\
2 & "A" & 1.8 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{long}\NormalTok{.pivot(}
\NormalTok{  index}\OperatorTok{=}\StringTok{\textquotesingle{}id\textquotesingle{}}\NormalTok{, }\CommentTok{\# index in the wide format}
\NormalTok{  columns}\OperatorTok{=}\StringTok{\textquotesingle{}treatment\textquotesingle{}}\NormalTok{, }\CommentTok{\# defines columns in the wide format}
\NormalTok{  values}\OperatorTok{=}\StringTok{\textquotesingle{}height\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/1142736381.py:1: DeprecationWarning:

In a future version of polars, the default `aggregate_function` will change from `'first'` to `None`. Please pass `'first'` to keep the current behaviour, or `None` to accept the new one.
\end{verbatim}

\begin{longtable}[]{@{}lll@{}}
\toprule()
id & A & B \\
i64 & f64 & f64 \\
\midrule()
\endhead
1 & 2.8 & 2.2 \\
2 & 2.0 & 1.9 \\
3 & 2.2 & 2.1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{long}\NormalTok{.unstack(step}\OperatorTok{=}\DecValTok{2}\NormalTok{) }\CommentTok{\# works like a transpose, and then wrap rows. Change the \textasciigrave{}step=\textasciigrave{} to get the feeling. }
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllllllll@{}}
\toprule()
id\_0 & id\_1 & id\_2 & id\_3 & id\_4 & treatment\_0 & treatment\_1 &
treatment\_2 & treatment\_3 & treatment\_4 & height\_0 & height\_1 &
height\_2 & height\_3 & height\_4 \\
i64 & i64 & i64 & i64 & i64 & str & str & str & str & str & f64 & f64 &
f64 & f64 & f64 \\
\midrule()
\endhead
1 & 1 & 2 & 3 & 3 & "A" & "B" & "A" & "A" & "B" & 2.8 & 2.2 & 1.8 & 2.2
& 2.1 \\
1 & 2 & 2 & 3 & null & "A" & "A" & "B" & "A" & null & 2.9 & 2.0 & 1.9 &
2.3 & null \\
\bottomrule()
\end{longtable}

\hypertarget{groupby}{%
\subsection{Groupby}\label{groupby}}

Grouping over categories:

\begin{itemize}
\tightlist
\item
  \texttt{df.partion\_by()} will return a list of frames.
\item
  \texttt{df.groupby()} for grouping. Just like pandas, only
  parallelized, etc. The output will have the length of the number of
  groups.
\item
  \texttt{over()} will assign each row the aggregate in the group. Like
  pandas \texttt{groupby.transform}. The output will have the same
  length as the input.
\end{itemize}

Grouping over time:

\begin{itemize}
\tightlist
\item
  \texttt{df.grouby\_rolling()} for rolling window grouping, a.k.a. a
  sliding window. Each row will be assigned the aggregate in the window.
\item
  \texttt{df.groupby\_dynamic()} for dynamic grouping. Each period will
  be assigned the agregate in the period. The output may have more rows
  than the input.
\end{itemize}

After grouping:

\begin{itemize}
\tightlist
\item
  \texttt{df.groupby().agg()} for aggregating.
\item
  \texttt{df.groupby().apply()} for applying a function to each group.
\item
  \texttt{df.groupby().count()} for counting.
\item
  \texttt{df.groupby().first()} for getting the first row of each group.
\item
  \ldots{}
\end{itemize}

See the
\href{https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/groupby.html}{API
reference} for the various options. Also see the
\href{https://pola-rs.github.io/polars-book/user-guide/howcani/timeseries/temporal_groupby.html}{user
guide} for more details.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df2 }\OperatorTok{=}\NormalTok{ pl.DataFrame(\{}
    \StringTok{"integer"}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{],}
    \StringTok{"float"}\NormalTok{: [}\FloatTok{1.0}\NormalTok{, }\FloatTok{2.0}\NormalTok{, }\FloatTok{3.0}\NormalTok{, }\FloatTok{4.0}\NormalTok{, }\FloatTok{5.0}\NormalTok{, }\FloatTok{6.0}\NormalTok{],}
    \StringTok{"string"}\NormalTok{: [}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{],}
    \StringTok{"datetime"}\NormalTok{: [}
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)), }
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)), }
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)), }
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{)), }
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{)), }
\NormalTok{        (datetime(}\DecValTok{2022}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{))],}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df2.partition\_by(}\StringTok{"integer"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[shape: (2, 4)
 ┌─────────┬───────┬────────┬─────────────────────┐
 │ integer ┆ float ┆ string ┆ datetime            │
 │ ---     ┆ ---   ┆ ---    ┆ ---                 │
 │ i64     ┆ f64   ┆ str    ┆ datetime[μs]        │
 ╞═════════╪═══════╪════════╪═════════════════════╡
 │ 1       ┆ 1.0   ┆ a      ┆ 2022-01-04 00:00:00 │
 │ 1       ┆ 2.0   ┆ b      ┆ 2022-01-04 00:00:00 │
 └─────────┴───────┴────────┴─────────────────────┘,
 shape: (2, 4)
 ┌─────────┬───────┬────────┬─────────────────────┐
 │ integer ┆ float ┆ string ┆ datetime            │
 │ ---     ┆ ---   ┆ ---    ┆ ---                 │
 │ i64     ┆ f64   ┆ str    ┆ datetime[μs]        │
 ╞═════════╪═══════╪════════╪═════════════════════╡
 │ 2       ┆ 3.0   ┆ c      ┆ 2022-01-04 00:00:00 │
 │ 2       ┆ 4.0   ┆ d      ┆ 2022-01-09 00:00:00 │
 └─────────┴───────┴────────┴─────────────────────┘,
 shape: (2, 4)
 ┌─────────┬───────┬────────┬─────────────────────┐
 │ integer ┆ float ┆ string ┆ datetime            │
 │ ---     ┆ ---   ┆ ---    ┆ ---                 │
 │ i64     ┆ f64   ┆ str    ┆ datetime[μs]        │
 ╞═════════╪═══════╪════════╪═════════════════════╡
 │ 3       ┆ 5.0   ┆ e      ┆ 2022-01-09 00:00:00 │
 │ 3       ┆ 6.0   ┆ f      ┆ 2022-01-09 00:00:00 │
 └─────────┴───────┴────────┴─────────────────────┘]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{groupper }\OperatorTok{=}\NormalTok{ df2.groupby(}\StringTok{"integer"}\NormalTok{)}
\NormalTok{groupper.count()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule()
integer & count \\
i64 & u32 \\
\midrule()
\endhead
1 & 2 \\
2 & 2 \\
3 & 2 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{groupper.}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & float & string & datetime \\
i64 & f64 & str & datetime{[}μs{]} \\
\midrule()
\endhead
2 & 7.0 & null & null \\
3 & 11.0 & null & null \\
1 & 3.0 & null & null \\
\bottomrule()
\end{longtable}

Groupby a fixed time window with \texttt{df.groupby\_dynamic()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}
\NormalTok{  df2}
\NormalTok{  .groupby\_dynamic(index\_column}\OperatorTok{=}\StringTok{"datetime"}\NormalTok{, every}\OperatorTok{=}\StringTok{"1d"}\NormalTok{)}
\NormalTok{  .agg(pl.col(}\StringTok{"float"}\NormalTok{).}\BuiltInTok{sum}\NormalTok{())}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
argument in operation 'groupby_dynamic' is not explicitly sorted

- If your data is ALREADY sorted, set the sorted flag with: '.set_sorted()'.
- If your data is NOT sorted, sort the 'expr/series/column' first.

This might become an error in a future version.
    
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
datetime & float \\
datetime{[}μs{]} & f64 \\
\midrule()
\endhead
2022-01-04 00:00:00 & 6.0 \\
2022-01-09 00:00:00 & 15.0 \\
\bottomrule()
\end{longtable}

If you do not want a single summary per period, rather, a window at each
datapoint, use \texttt{df.groupby\_rolling()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}
\NormalTok{  df2}
\NormalTok{  .groupby\_rolling(index\_column}\OperatorTok{=}\StringTok{"datetime"}\NormalTok{, period}\OperatorTok{=}\StringTok{\textquotesingle{}1d\textquotesingle{}}\NormalTok{)}
\NormalTok{  .agg(pl.col(}\StringTok{"float"}\NormalTok{).}\BuiltInTok{sum}\NormalTok{())}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
argument in operation 'groupby_rolling' is not explicitly sorted

- If your data is ALREADY sorted, set the sorted flag with: '.set_sorted()'.
- If your data is NOT sorted, sort the 'expr/series/column' first.

This might become an error in a future version.
    
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
datetime & float \\
datetime{[}μs{]} & f64 \\
\midrule()
\endhead
2022-01-04 00:00:00 & 1.0 \\
2022-01-04 00:00:00 & 3.0 \\
2022-01-04 00:00:00 & 6.0 \\
2022-01-09 00:00:00 & 4.0 \\
2022-01-09 00:00:00 & 9.0 \\
2022-01-09 00:00:00 & 15.0 \\
\bottomrule()
\end{longtable}

\hypertarget{over}{%
\subsubsection{Over}\label{over}}

You may be familar with pandas \texttt{groupby().transform()}, which
will return a frame with the same row-count as its input. You may be
familiar with Postgres SQL
\href{https://www.postgresql.org/docs/current/tutorial-window.html}{window
function}. You may not be familiar with either, and still want to
aggregate within group, but propagate the result to all group members.
Polars' \texttt{over()} is the answer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{  pl.col(}\StringTok{"float"}\NormalTok{).}\BuiltInTok{sum}\NormalTok{().over(}\StringTok{"string"}\NormalTok{).alias(}\StringTok{"sum"}\NormalTok{)}
\NormalTok{).limit(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & sum \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 4.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 5.0 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 6.0 \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & 24.0 \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & 24.0 \\
\bottomrule()
\end{longtable}

\textbf{Careful}: \texttt{over()} should follow the aggregation. The
following will not fail, but return the wrong result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.with\_columns(}
\NormalTok{  pl.col(}\StringTok{"float"}\NormalTok{).over(}\StringTok{"string"}\NormalTok{).}\BuiltInTok{sum}\NormalTok{().alias(}\StringTok{"sum"}\NormalTok{)}
\NormalTok{).limit(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & sum \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 39.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 39.0 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 39.0 \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & 39.0 \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & 39.0 \\
\bottomrule()
\end{longtable}

\hypertarget{processing-multiple-frames-simultanously}{%
\subsection{Processing Multiple Frames
Simultanously}\label{processing-multiple-frames-simultanously}}

Q: What if you want to access a column from frame \texttt{df}, when
processing frame \texttt{df2}?\\
A: Just join them.\\
Q: What if they are not joinable?\\
A: Use a diagonal join. Q: Can't I just add a search-space into the lazy
query? A: Ahhh! Use \texttt{df.with\_context()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df3 }\OperatorTok{=}\NormalTok{ pl.Series(}\StringTok{"blah"}\NormalTok{, [}\DecValTok{100}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]).to\_frame()}

\NormalTok{q }\OperatorTok{=}\NormalTok{ (}
\NormalTok{    df.lazy()}
\NormalTok{    .with\_context( }\CommentTok{\# add colums of df2 to the search space}
\NormalTok{        df3.lazy()}
\NormalTok{        )}
\NormalTok{    .with\_columns(}
\NormalTok{        pl.col(}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{).map\_dict(remapping}\OperatorTok{=}\NormalTok{\{}\FloatTok{4.0}\NormalTok{:}\VariableTok{None}\NormalTok{\}, default}\OperatorTok{=}\DecValTok{100}\NormalTok{).fill\_null(pl.col(}\StringTok{\textquotesingle{}blah\textquotesingle{}}\NormalTok{).mean()).alias(}\StringTok{\textquotesingle{}float2\textquotesingle{}}\NormalTok{),}
\NormalTok{        )}
\NormalTok{    )}

\NormalTok{q.collect()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
integer & date & float & string & float2 \\
i64 & datetime{[}μs{]} & f64 & str & f64 \\
\midrule()
\endhead
1 & 2022-01-01 00:00:00 & 4.0 & "a" & 35.0 \\
2 & 2022-01-02 00:00:00 & 5.0 & "b" & 100.0 \\
3 & 2022-01-03 00:00:00 & 6.0 & "c" & 100.0 \\
1 & 2022-01-04 00:00:00 & 7.0 & "d" & 100.0 \\
2 & 2022-01-05 00:00:00 & 8.0 & "d" & 100.0 \\
3 & 2022-01-06 00:00:00 & 9.0 & "d" & 100.0 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  \texttt{with\_context()} is a lazy operation. This is great news,
  since it means both frames will benefit from query planning, etc.
\item
  \texttt{with\_context()} will not copy the data, but rather, add a
  reference to the data.
\item
  Why not use
  \texttt{pl.col(\textquotesingle{}blah\textquotesingle{}).mean()}
  within the \texttt{map\_dict()}? That is indeed more reasonable. It
  simply did not work.
\item
  Try it yourself: Can you use multiple \texttt{with\_context()}?
\end{itemize}

\hypertarget{sec-query-planning}{%
\section{Query Planning and Optimization}\label{sec-query-planning}}

The take-home of this section, is that polar can take advantage of
half-a-century's worth of research in query planning and optimization.
You will not have to think about the right order of operations, or the
right data structures to use. Rather, replace the polars dataframe with
a polars lazy-dataframe, state all the operations you want, and just
finish with a \texttt{collect()}. Polars will take care of the rest, and
provide you with the tools to understand its plan.

We will not go into the details of the difference between a lazy and a
non-lazy dataframe. Just assume a lazy frame allows everything a
non-lazy frame can do, but it does not execute the operations until you
call \texttt{collect()}. This is not entirely true, but you will get an
informative error if you try to do something that is not supported.

Get your lazy dataframe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_lazy }\OperatorTok{=}\NormalTok{ df.lazy()}
\end{Highlighting}
\end{Shaded}

State all your operations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q }\OperatorTok{=}\NormalTok{ (}
\NormalTok{  df\_lazy}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{2.0}\NormalTok{)}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{3.0}\NormalTok{)}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{7.0}\NormalTok{)}
\NormalTok{  .select([}\StringTok{"integer"}\NormalTok{])}
\NormalTok{  .sort(}\StringTok{"integer"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And now visualize the query.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q }\CommentTok{\# same as q.show\_graph(optimized=False)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<polars.LazyFrame object at 0x29F419C10>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.show\_graph(optimized}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-336-output-1.svg}

}

\end{figure}

Things to note:

\begin{itemize}
\tightlist
\item
  You will need Graphviz installed to visualize the query plan.
\item
  To understand the plan, you need some terminology from
  \href{https://www.ibm.com/docs/en/informix-servers/14.10?topic=concepts-selection-projection}{relational
  databases}. Namely:

  \begin{itemize}
  \tightlist
  \item
    A \emph{selection} is a polars' filter, i.e.~subset of rows, marked
    in the graph with a \(\sigma\).
  \item
    A \emph{projection} is polars seletion, i.e.~a subset of columns,
    marked in the graph with a \(\pi\).
  \end{itemize}
\item
  The optimized plan removes redudancies, and orders the operations in
  the most efficient way.
\end{itemize}

You can now execute the plan with a \texttt{collect()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.collect()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.describe\_plan()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/3358036380.py:1: DeprecationWarning:

`LazyFrame.describe_plan` has been deprecated; Please use `LazyFrame.explain` instead
\end{verbatim}

\begin{verbatim}
'SORT BY [col("integer")]\n   SELECT [col("integer")] FROM\n    FILTER [(col("float")) > (7.0)] FROM\n    FILTER [(col("float")) > (3.0)] FROM\n    FILTER [(col("float")) > (2.0)] FROM\n    DF ["integer", "date", "float", "string"]; PROJECT */4 COLUMNS; SELECTION: "None"'
\end{verbatim}

\hypertarget{inspecting-profiling-and-debugging-a-query}{%
\subsection{Inspecting, Profiling, and Debugging a
Query}\label{inspecting-profiling-and-debugging-a-query}}

For early stopping (debugging?) you can replace \texttt{collect()} with
\texttt{fetch()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.fetch(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
\bottomrule()
\end{longtable}

You can inspect the data at any point in the query.
\texttt{df.inspect()} will print the state of a single node in the query
graph: {[}TODO: replace with example with multiple nodes{]}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q }\OperatorTok{=}\NormalTok{ (}
\NormalTok{    pl.scan\_parquet(}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{path}\SpecialCharTok{\}}\SpecialStringTok{/*.parquet\textquotesingle{}}\NormalTok{)}
\NormalTok{    .}\BuiltInTok{filter}\NormalTok{(}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}trip\_distance\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}trip\_distance\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}fare\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}fare\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{100}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{20}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}total\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}
\NormalTok{        (pl.col(}\StringTok{\textquotesingle{}total\_amount\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{100}\NormalTok{)}
\NormalTok{    )}
\NormalTok{    .inspect() }\CommentTok{\# here is the inspect}
\NormalTok{    .groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{)}
\NormalTok{    .agg([pl.mean(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{)])}
\NormalTok{    )}
\NormalTok{q.collect()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
shape: (3_537_967, 5)
┌────────────┬─────────────────┬───────────────┬─────────────┬──────────────┐
│ tip_amount ┆ passenger_count ┆ trip_distance ┆ fare_amount ┆ total_amount │
│ ---        ┆ ---             ┆ ---           ┆ ---         ┆ ---          │
│ f64        ┆ f64             ┆ f64           ┆ f64         ┆ f64          │
╞════════════╪═════════════════╪═══════════════╪═════════════╪══════════════╡
│ 3.65       ┆ 2.0             ┆ 3.8           ┆ 14.5        ┆ 21.95        │
│ 4.0        ┆ 1.0             ┆ 2.1           ┆ 8.0         ┆ 13.3         │
│ 1.76       ┆ 1.0             ┆ 0.97          ┆ 7.5         ┆ 10.56        │
│ 3.0        ┆ 1.0             ┆ 4.3           ┆ 23.5        ┆ 30.3         │
│ …          ┆ …               ┆ …             ┆ …           ┆ …            │
│ 3.5        ┆ 2.0             ┆ 1.7           ┆ 8.0         ┆ 15.3         │
│ 2.26       ┆ 1.0             ┆ 1.2           ┆ 7.5         ┆ 13.56        │
│ 4.86       ┆ 1.0             ┆ 5.62          ┆ 20.5        ┆ 29.16        │
│ 2.36       ┆ 1.0             ┆ 1.9           ┆ 8.0         ┆ 14.16        │
└────────────┴─────────────────┴───────────────┴─────────────┴──────────────┘
\end{verbatim}

\begin{verbatim}
PARTITIONED DS
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
passenger\_count & tip\_amount \\
f64 & f64 \\
\midrule()
\endhead
1.0 & 2.701872 \\
4.0 & 2.782241 \\
2.0 & 2.749387 \\
3.0 & 2.715053 \\
\bottomrule()
\end{longtable}

You can profile the execution of a query with \texttt{df.profile()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.profile(show\_plot}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
PARTITIONED DS
\end{verbatim}

\begin{verbatim}
shape: (3_537_967, 5)
┌────────────┬─────────────────┬───────────────┬─────────────┬──────────────┐
│ tip_amount ┆ passenger_count ┆ trip_distance ┆ fare_amount ┆ total_amount │
│ ---        ┆ ---             ┆ ---           ┆ ---         ┆ ---          │
│ f64        ┆ f64             ┆ f64           ┆ f64         ┆ f64          │
╞════════════╪═════════════════╪═══════════════╪═════════════╪══════════════╡
│ 3.65       ┆ 2.0             ┆ 3.8           ┆ 14.5        ┆ 21.95        │
│ 4.0        ┆ 1.0             ┆ 2.1           ┆ 8.0         ┆ 13.3         │
│ 1.76       ┆ 1.0             ┆ 0.97          ┆ 7.5         ┆ 10.56        │
│ 3.0        ┆ 1.0             ┆ 4.3           ┆ 23.5        ┆ 30.3         │
│ …          ┆ …               ┆ …             ┆ …           ┆ …            │
│ 3.5        ┆ 2.0             ┆ 1.7           ┆ 8.0         ┆ 15.3         │
│ 2.26       ┆ 1.0             ┆ 1.2           ┆ 7.5         ┆ 13.56        │
│ 4.86       ┆ 1.0             ┆ 5.62          ┆ 20.5        ┆ 29.16        │
│ 2.36       ┆ 1.0             ┆ 1.9           ┆ 8.0         ┆ 14.16        │
└────────────┴─────────────────┴───────────────┴─────────────┴──────────────┘
\end{verbatim}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-341-output-3.pdf}

}

\end{figure}

\begin{verbatim}
(shape: (4, 2)
 ┌─────────────────┬────────────┐
 │ passenger_count ┆ tip_amount │
 │ ---             ┆ ---        │
 │ f64             ┆ f64        │
 ╞═════════════════╪════════════╡
 │ 1.0             ┆ 2.701872   │
 │ 4.0             ┆ 2.782241   │
 │ 2.0             ┆ 2.749387   │
 │ 3.0             ┆ 2.715053   │
 └─────────────────┴────────────┘,
 shape: (8, 3)
 ┌───────────────────────────────────┬───────┬───────┐
 │ node                              ┆ start ┆ end   │
 │ ---                               ┆ ---   ┆ ---   │
 │ str                               ┆ u64   ┆ u64   │
 ╞═══════════════════════════════════╪═══════╪═══════╡
 │ optimization                      ┆ 0     ┆ 491   │
 │ parquet(data/NYC/yellow_tripdata… ┆ 33    ┆ 60520 │
 │ parquet(data/NYC/yellow_tripdata… ┆ 491   ┆ 50482 │
 │ FAST_PROJECT: [tip_amount, passe… ┆ 50486 ┆ 50490 │
 │ FAST_PROJECT: [tip_amount, passe… ┆ 60528 ┆ 60530 │
 │ ANONYMOUS UDF                     ┆ 60571 ┆ 60830 │
 │ groupby_partitioned(passenger_co… ┆ 60831 ┆ 82396 │
 │ PIPELINE                          ┆ 63419 ┆ 82391 │
 │                                   ┆       ┆       │
 └───────────────────────────────────┴───────┴───────┘)
\end{verbatim}

\hypertarget{exporting-a-query}{%
\subsection{Exporting a Query}\label{exporting-a-query}}

You can export your query, as a JSON file.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.write\_json(}\StringTok{"query.json"}\NormalTok{) }\CommentTok{\# export}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ValueError: Error("the enum variant FunctionNode::Opaque cannot be serialized", line: 0, column: 0)
\end{verbatim}

This is how the query will look on disk:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ json}
\NormalTok{json.loads(}\BuiltInTok{open}\NormalTok{(}\StringTok{"query.json"}\NormalTok{).read())}\CommentTok{\# inspect}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
JSONDecodeError: Expecting value: line 1 column 3376 (char 3375)
\end{verbatim}

You can now load it and run it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.LazyFrame.read\_json(}\StringTok{"query.json"}\NormalTok{).collect() }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ValueError: Error("EOF while parsing a value", line: 1, column: 3375)
\end{verbatim}

\hypertarget{sql-flavor}{%
\subsection{SQL Flavor}\label{sql-flavor}}

If you are a hardcore SQL user, you may want to use the SQL flavor of
polars. The following syntax is experimental, and may change.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql }\OperatorTok{=}\NormalTok{ pl.SQLContext() }
\NormalTok{sql.register(}\StringTok{"lazy\_frame"}\NormalTok{, lazy\_frame) }\CommentTok{\# register the lazy frame as a table}

\NormalTok{sql.query(}\StringTok{"""}
\StringTok{    SELECT passenger\_count, AVG(tip\_amount) FROM lazy\_frame }
\StringTok{    WHERE passenger\_count \textless{} 3}
\StringTok{    GROUP BY passenger\_count}
\StringTok{    """}\NormalTok{) }\CommentTok{\# query the table}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NameError: name 'lazy_frame' is not defined
\end{verbatim}

\hypertarget{io}{%
\section{I/O}\label{io}}

You will find that polars is blazing fast at reading and writing data.
This is due to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Very good heuristics/rules implemented in the \texttt{read\_csv}
  function.
\item
  The use of \href{https://arrow.apache.org/}{Apache Arrow} as an
  internal data structure, which maps seamlesly to the parquet file
  format.
\item
  Parallelism, whenever possible.
\item
  Lazy scans/imports, which allows the materialization only of required
  data; i.e., filters and projections are executed at scan time.
\end{enumerate}

\hypertarget{import}{%
\subsection{Import}\label{import}}

High level:

\begin{itemize}
\tightlist
\item
  \texttt{pl.read\_X()} will read a file into a non-lazy frame.
\item
  \texttt{pl.scan\_X()} will read a file into a lazy frame.
\item
  You can use globs to import multiple files but:

  \begin{itemize}
  \tightlist
  \item
    You may need to teak schema manually.
  \item
    Filesystme operations are handeled by
    \href{https://filesystem-spec.readthedocs.io/en/latest/}{fsspec},
    which may open only the first file when using globs in remote
    filesystems (e.g.~S3). This is discussed in
    Section~\ref{sec-multiple-files}.
  \end{itemize}
\end{itemize}

\hypertarget{from-a-single-file}{%
\subsubsection{From a Single File}\label{from-a-single-file}}

Let's firs make a csv to import:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.write\_csv(}\StringTok{"df.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Import the csv into a non-lazy frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl.read\_csv(}\StringTok{"df.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
integer & date & float & string \\
i64 & str & f64 & str \\
\midrule()
\endhead
1 & "2022-01-01T00:\ldots{} & 4.0 & "a" \\
2 & "2022-01-02T00:\ldots{} & 5.0 & "b" \\
3 & "2022-01-03T00:\ldots{} & 6.0 & "c" \\
1 & "2022-01-04T00:\ldots{} & 7.0 & "d" \\
2 & "2022-01-05T00:\ldots{} & 8.0 & "d" \\
3 & "2022-01-06T00:\ldots{} & 9.0 & "d" \\
\bottomrule()
\end{longtable}

Importing as a lazy frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_lazy }\OperatorTok{=}\NormalTok{ pl.scan\_csv(}\StringTok{"df.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Things become interesting when you manipulate the lazy frame before
materializing it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q }\OperatorTok{=}\NormalTok{ (}
\NormalTok{  df\_lazy}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{2.0}\NormalTok{)}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{3.0}\NormalTok{)}
\NormalTok{  .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{"float"}\NormalTok{) }\OperatorTok{\textgreater{}} \FloatTok{7.0}\NormalTok{)}
\NormalTok{  .select([}\StringTok{"integer"}\NormalTok{])}
\NormalTok{  .sort(}\StringTok{"integer"}\NormalTok{)}
\NormalTok{)}

\NormalTok{q.show\_graph(optimized}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-349-output-1.svg}

}

\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q.collect()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}l@{}}
\toprule()
integer \\
i64 \\
\midrule()
\endhead
2 \\
3 \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  From the graph we see that the filtering (\(\sigma\)) is done at scan
  time, and not after the materialization of the data. This is crucial
  for processing datasets that are larger then memory.
\item
  To get the actual data, we naturally need to \texttt{collect()}.
\end{itemize}

Cleary, .csv is not the only format that can be read. It is possibly the
least recommended. Other file types can be found
\href{https://pola-rs.github.io/polars/py-polars/html/reference/io.html}{here}
and include:

\begin{itemize}
\tightlist
\item
  Excel.
\item
  Arrow IPC: A binary format for storing columnar data.
\item
  Feather (V2): Multiple IPC files with a shared schema.
\item
  Parquet (non-partitioned): A tabular file format (not columnar) that
  is optimized for long-term storage, more compressed than Feather.
\item
  JSON: Short for JavaScript Object Notation, a textual data-interchange
  format (like XML).
\item
  Avro: A binary row-based format. Good for streaming.
\end{itemize}

Each of the above formats has a non-lazy reader using
\texttt{pl.read\_*} and a lazy reader using \texttt{pl.scan\_*}.

Currently unsuported formats:

\begin{itemize}
\tightlist
\item
  Feather (V1).
\item
  \href{https://github.com/pola-rs/polars/issues/3520}{HDF5}.
\end{itemize}

\hypertarget{from-multiple-files-in-your-filesystem}{%
\subsubsection{From Multiple Files in Your
Filesystem}\label{from-multiple-files-in-your-filesystem}}

Most of today's datasets will span more than a single file on disk.
Polar supports reading from multiple files in your file system (as
opposed to a remote datalake such as S3), and will automatically merge
them into a single dataframe. There are, however, many file formats, and
each has its own way of partitioning the data. Multi-file storage
supported by polars (at the time of writing):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Parquet (partitioned): A collection of files with a common schema,
  partitioned as folders on disk.
\item
  \href{https://www.databricks.com/wp-content/uploads/2020/08/p975-armbrust.pdf}{Delta-Lake}:
  If your data is saves as many parquet files on S3, a failed copy
  operation may ``break'' the data. Systems that protect data from such
  failures (failed copy is only an example) are called ``transactional
  systems'', and the garantees they provide are called
  \href{https://www.databricks.com/glossary/acid-transactions}{``ACID''}.
  A Delta-Lake, is a piece of open source software, that manages your
  queries to give your data-lake the ACID properties.
\item
  \href{https://arrow.apache.org/docs/python/dataset.html}{Arrow
  Dataset}: A collection of files (csv, parquet, feather, etc) with a
  common schema.
\end{enumerate}

TODO:
https://pola-rs.github.io/polars-book/user-guide/multiple\_files/intro.html

\hypertarget{sec-multiple-files}{%
\paragraph{Arbitrary Collection of Files}\label{sec-multiple-files}}

You can always scan from some arbitrary collection of files and
concatenate the result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path }\OperatorTok{=} \StringTok{\textquotesingle{}data/NYC\textquotesingle{}} \CommentTok{\# Data from https://www.nyc.gov/site/tlc/about/tlc{-}trip{-}record{-}data.page}
\NormalTok{file\_names }\OperatorTok{=}\NormalTok{ os.listdir(path)}
\NormalTok{file\_names}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['.DS_Store',
 'yellow_tripdata_2022-01.parquet',
 'yellow_tripdata_2022-02.parquet']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_lazy\_list }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for} \BuiltInTok{file} \KeywordTok{in}\NormalTok{ file\_names:}
\NormalTok{    df\_lazy\_list.append(}
\NormalTok{        pl.scan\_parquet(}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{path}\SpecialCharTok{\}}\SpecialStringTok{/}\SpecialCharTok{\{}\BuiltInTok{file}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{        )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ArrowErrorException: ExternalFormat("File out of specification: The file must end with PAR1")
\end{verbatim}

With a list of lazy frames you can proceed by concatenating into a
single lazy frame using \texttt{pl.concat()}, or collecting them into a
list of eager frames using \texttt{pl.collect\_all()}. The best option
depends on your use case.

Things to note:

\begin{itemize}
\tightlist
\item
  The arrow data format uses caching for string and categorical data
  (i.e.~pl.Series). If importing multiple files, such as multiple
  parquet/feather files, or an arrow dataset, different files may be
  cached differnetly. This will cause an error when trying to
  concatenate the dataframes. To avoid this, you can disable string
  caching, or enforce
  \href{https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.StringCache.html}{joint
  caching} of all files.
\item
  Dataframes may have incompatible schema, as discussed in
  Section~\ref{sec-joins} above. You may need to manually adjust the
  schema before concatenating.
\end{itemize}

Here is an example that deals with both issues:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with}\NormalTok{ pl.StringCache(): }\CommentTok{\# Enforce joint caching of all files}
\NormalTok{  df\_lazy\_list }\OperatorTok{=}\NormalTok{ []}
  \ControlFlowTok{for} \BuiltInTok{file} \KeywordTok{in}\NormalTok{ file\_names:}
\NormalTok{    lazy\_frame }\OperatorTok{=}\NormalTok{ (}
\NormalTok{        pl.scan\_parquet(}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{path}\SpecialCharTok{\}}\SpecialStringTok{/}\SpecialCharTok{\{}\BuiltInTok{file}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{) }\CommentTok{\# read a lazy frame}
\NormalTok{        .with\_columns(}
\NormalTok{            pl.col(pl.Datetime(}\StringTok{\textquotesingle{}ns\textquotesingle{}}\NormalTok{)).dt.cast\_time\_unit(}\StringTok{\textquotesingle{}ms\textquotesingle{}}\NormalTok{)}
\NormalTok{            ) }\CommentTok{\# ensure joinable time units}
\NormalTok{    )}
\NormalTok{    df\_lazy\_list.append(lazy\_frame)}

\NormalTok{q}\OperatorTok{=}\NormalTok{ (}
\NormalTok{    pl.concat(df\_lazy\_list) }\CommentTok{\# concat into into a single lazy frame}
\NormalTok{    .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{)}
\NormalTok{    .groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{)}
\NormalTok{    .agg([pl.mean(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{)])}
\NormalTok{)}
\NormalTok{q.collect() }\CommentTok{\# execute query}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ArrowErrorException: ExternalFormat("File out of specification: The file must end with PAR1")
\end{verbatim}

\hypertarget{partitioned-parquet}{%
\paragraph{Partitioned Parquet}\label{partitioned-parquet}}

The code snipped above (@sec- multiple\_files) is fully generalizable
wrt the files you import and what you do to them. Most often, you don't
need such generality. For instance, when importing multiple parquet
files form the local file system, the \texttt{pl.read\_parquet()}
function will allow you to use globs. The above may thus read:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with}\NormalTok{ pl.StringCache(): }\CommentTok{\# Enforce joint caching of all files}
\NormalTok{  lazy\_frame }\OperatorTok{=}\NormalTok{ pl.scan\_parquet(}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{path}\SpecialCharTok{\}}\SpecialStringTok{/*.parquet\textquotesingle{}}\NormalTok{)}
  
\NormalTok{q}\OperatorTok{=}\NormalTok{ (}
\NormalTok{    lazy\_frame }\CommentTok{\# concat into into a single lazy frame}
\NormalTok{    .}\BuiltInTok{filter}\NormalTok{(pl.col(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{) }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{)}
\NormalTok{    .groupby(}\StringTok{\textquotesingle{}passenger\_count\textquotesingle{}}\NormalTok{)}
\NormalTok{    .agg([pl.mean(}\StringTok{\textquotesingle{}tip\_amount\textquotesingle{}}\NormalTok{)])}
\NormalTok{)}
\NormalTok{q.collect() }\CommentTok{\# execute query}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
PARTITIONED DS
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule()
passenger\_count & tip\_amount \\
f64 & f64 \\
\midrule()
\endhead
1.0 & 2.400686 \\
0.0 & 2.273948 \\
2.0 & 2.579188 \\
\bottomrule()
\end{longtable}

\hypertarget{apache-arrow-dataset}{%
\paragraph{Apache Arrow Dataset}\label{apache-arrow-dataset}}

TODO: The exampe below deals with partitioned parquet, and not arrow
datasets. Fix.

An Apache Arrow dataset is a collection of parquet files, with an index
file. It is a very efficient way to store data on disk, and to read it
in parallel.

Writing an Arrow dataset:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Write df as an arrow dataset:}
\NormalTok{df.to\_pandas().to\_parquet(}
    \StringTok{"df"}\NormalTok{, }
\NormalTok{    engine}\OperatorTok{=}\StringTok{"pyarrow"}\NormalTok{, }
\NormalTok{    partition\_cols}\OperatorTok{=}\NormalTok{[}\StringTok{"integer"}\NormalTok{])}

\NormalTok{os.listdir(}\StringTok{"df"}\NormalTok{) }\CommentTok{\# inspect folder on disk}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['integer=1', 'integer=2', 'integer=3']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# inspect partitions}
\NormalTok{[os.listdir(}\SpecialStringTok{f"df/}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{\}}\SpecialStringTok{/"}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ os.listdir(}\StringTok{"df"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[['1559a4206059411189908002b1b05e14-0.parquet'],
 ['1559a4206059411189908002b1b05e14-0.parquet'],
 ['1559a4206059411189908002b1b05e14-0.parquet']]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pyarrow.dataset }\ImportTok{as}\NormalTok{ ds}
\NormalTok{dset }\OperatorTok{=}\NormalTok{ ds.dataset(}\StringTok{"df"}\NormalTok{, }\BuiltInTok{format}\OperatorTok{=}\StringTok{"parquet"}\NormalTok{)  }\CommentTok{\# define folder as dataset}
\NormalTok{pl.scan\_ds(dset).collect() }\CommentTok{\# import}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/91/c3y_9h950pb0gq8c8sdytk1r0000gn/T/ipykernel_85263/385436092.py:3: DeprecationWarning:

`scan_ds` has been renamed; this redirect is temporary, please use `scan_pyarrow_dataset` instead
\end{verbatim}

\begin{longtable}[]{@{}lll@{}}
\toprule()
date & float & string \\
datetime{[}μs{]} & f64 & str \\
\midrule()
\endhead
2022-01-01 00:00:00 & 4.0 & "a" \\
2022-01-04 00:00:00 & 7.0 & "d" \\
2022-01-02 00:00:00 & 5.0 & "b" \\
2022-01-05 00:00:00 & 8.0 & "d" \\
2022-01-03 00:00:00 & 6.0 & "c" \\
2022-01-06 00:00:00 & 9.0 & "d" \\
\bottomrule()
\end{longtable}

Things to note:

\begin{itemize}
\tightlist
\item
  We used pandas to write the arrow dataset. It seemed easier than the
  \href{https://arrow.apache.org/docs/python/dataset.html\#dataset}{pyarrow
  syntax}.
\item
  The \texttt{partition\_cols} argument is used to partition the dataset
  on disk. Each partition is a parquet file (or another partition).
\item
  Reading from the web (not from the local filesystem) is slightly
  different. TODO: add reference.
\end{itemize}

\hypertarget{multiple-csvs}{%
\paragraph{Multiple CSVs}\label{multiple-csvs}}

TODO: \texttt{pl.read\_csv\_batched()}

\hypertarget{from-multiple-files-on-a-remote-datalake}{%
\subsubsection{From Multiple Files on a Remote
Datalake}\label{from-multiple-files-on-a-remote-datalake}}

If you are coming from Pandas, reading from a remote datalake (say S3),
and a local filesystem may feel the same. This is because the authors of
pandas went to great lengths to make the API feel the same. At the time
of writing, if you give polars a remote glob, it will only read the
first file (\href{https://github.com/pola-rs/polars/issues/5863}{ref}).

Your current options for reading multiple files stored remotely are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Read one file at a time, and concatenate the results, or use the
  \texttt{pl.scan\_parquet()} as in @sec- multiple\_files.
\item
  Use third party functionality that can link to multiple remote files.
  Luckily, the pyarrow library gives you this functionality. See
  \href{https://pola-rs.github.io/polars-book/user-guide/howcani/io/aws.html}{here}
  for an example.
\end{enumerate}

\hypertarget{reading-from-a-database}{%
\subsubsection{Reading from a Database}\label{reading-from-a-database}}

See
\href{https://pola-rs.github.io/polars-book/user-guide/howcani/io/read_db.html}{here}.

\hypertarget{serverless}{%
\subsubsection{Serverless}\label{serverless}}

See \href{https://www.rhosignal.com/posts/polars-aws-lambda/}{here} for
working in serverless environments such as AWS Lambda.

\hypertarget{sec-disk-export}{%
\subsection{Export to Disk}\label{sec-disk-export}}

Well, there is not much to say here; just look for \texttt{pl.write\_*}
functions. Alternatively, export to pandas, arrow, numpy, and use their
exporters.

\hypertarget{plotting}{%
\section{Plotting}\label{plotting}}

To get an intuition of what you may expect in this chapter you should
know the following. There are various approaches to plotting in python:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The object oriented, where a dataframe has a plotting method. E.g.
  \texttt{df.plot()}. The method may use a single, or even multiple
  backends. Such is the pandas dataframe, which may use a matplotlib,
  plotly, or bokeh backend.
\item
  The functional method, where a plotting function takes a dataframe as
  an argument. E.g. \texttt{plot(df)}. Such are the matplotlib, seaborn,
  and plotly functions, which may take pandas dataframes as inputs.
\end{enumerate}

Plotting support in polars thus boils down to the folowing questions:
(1) Do polars dataframes have a plotting method? With which backend? (2)
Can plotting functions take polars dataframes as inputs?

The answer to the first is negative. Polars dataframes do not have a
plotting method, and it seems they are not planned to have one (TODO:
add reference). The answer to the second is ``almost yes''. Any plotting
function that can take an iterable such as a list, or numpy 1D arrays,
will work. Either becaus polars series are iterable, or because one can
convert them (to arrow or numpy being the fastest).

Passing polars frames may cause trouble. You may expect to use a
\texttt{plot(df,\ x=\textquotesingle{}col1\textquotesingle{},\ y=\textquotesingle{}col2\textquotesingle{})}
syntax; it may work if \texttt{df} is a pandas dataframe, but not with
polars. Support of this syntax does not depend on polars developers,
rather, on the plotting function developpers. I suspect that the plotly
and bokeh teams will eventually supprts polars. I do not know about the
seaborm, or matplotlib teams.

The current state of affairs:

\begin{itemize}
\tightlist
\item
  Plotly, matplotlib, and seaborn support polars series as input.
\item
  Matplotlib and seaborn support polars frames as input. Plotly (5.12.0)
  does not.
\end{itemize}

\hypertarget{plotly-functions}{%
\subsection{Plotly Functions}\label{plotly-functions}}

The \texttt{iris} dataset is provided by plotly as a pandas frame. We
convert it to a polars frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{=}\NormalTok{ pl.DataFrame(px.data.iris())}
\NormalTok{iris.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllll@{}}
\toprule()
sepal\_length & sepal\_width & petal\_length & petal\_width & species &
species\_id \\
f64 & f64 & f64 & f64 & str & i64 \\
\midrule()
\endhead
5.1 & 3.5 & 1.4 & 0.2 & "setosa" & 1 \\
4.9 & 3.0 & 1.4 & 0.2 & "setosa" & 1 \\
4.7 & 3.2 & 1.3 & 0.2 & "setosa" & 1 \\
4.6 & 3.1 & 1.5 & 0.2 & "setosa" & 1 \\
5.0 & 3.6 & 1.4 & 0.2 & "setosa" & 1 \\
\bottomrule()
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig }\OperatorTok{=}\NormalTok{ px.scatter(}
\NormalTok{    x}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_width"}\NormalTok{].to\_list(), }
\NormalTok{    y}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_length"}\NormalTok{].to\_list())}
\NormalTok{fig.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unable to display output for mime type(s): application/vnd.plotly.v1+json, text/html
\end{verbatim}

But wait! Maybe a polars series is ``array-like'' and can be used as
input? Yes it can!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig }\OperatorTok{=}\NormalTok{ px.scatter(}
\NormalTok{    x}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_width"}\NormalTok{], }
\NormalTok{    y}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_length"}\NormalTok{])}
\NormalTok{fig.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unable to display output for mime type(s): application/vnd.plotly.v1+json, text/html
\end{verbatim}

Can a polars frame be used as input? No it can not. The following will
currently not work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig }\OperatorTok{=}\NormalTok{ px.scatter(}
\NormalTok{    data\_frame}\OperatorTok{=}\NormalTok{iris,}
\NormalTok{    x}\OperatorTok{=}\StringTok{"sepal\_width"}\NormalTok{,}
\NormalTok{    y}\OperatorTok{=}\StringTok{"sepal\_length"}\NormalTok{)}
\NormalTok{fig.show()}
\end{Highlighting}
\end{Shaded}

\hypertarget{matplotlib-functions}{%
\subsection{Matplotlib Functions}\label{matplotlib-functions}}

The above discussion applies to matplotlib functions as well; with the
exception that matplotlib functions already support polars frames as
input.

Inputing polars series:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig, ax }\OperatorTok{=}\NormalTok{ plt.subplots()}
\NormalTok{ax.scatter(}
\NormalTok{    x}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_width"}\NormalTok{], }
\NormalTok{    y}\OperatorTok{=}\NormalTok{iris[}\StringTok{"sepal\_length"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<matplotlib.collections.PathCollection at 0x290f88eb0>
\end{verbatim}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-363-output-2.pdf}

}

\end{figure}

Inputing polars frames:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig, ax }\OperatorTok{=}\NormalTok{ plt.subplots()}
\NormalTok{ax.scatter(}
\NormalTok{    data}\OperatorTok{=}\NormalTok{iris,}
\NormalTok{    x}\OperatorTok{=}\StringTok{"sepal\_width"}\NormalTok{,}
\NormalTok{    y}\OperatorTok{=}\StringTok{"sepal\_length"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<matplotlib.collections.PathCollection at 0x296ce0370>
\end{verbatim}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-364-output-2.pdf}

}

\end{figure}

\hypertarget{seborn-functions}{%
\subsection{Seborn Functions}\label{seborn-functions}}

Because Seaborn uses a matplotlib backend, the above discussion applies
to seaborn functions as well.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ seaborn }\ImportTok{as}\NormalTok{ sns}
\NormalTok{sns.scatterplot(}
\NormalTok{    data}\OperatorTok{=}\NormalTok{iris,}
\NormalTok{    x}\OperatorTok{=}\StringTok{"sepal\_width"}\NormalTok{,}
\NormalTok{    y}\OperatorTok{=}\StringTok{"sepal\_length"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<AxesSubplot: xlabel='sepal_width', ylabel='sepal_length'>
\end{verbatim}

\begin{figure}[H]

{\centering \includegraphics{polars_to_preview_files/figure-pdf/cell-365-output-2.pdf}

}

\end{figure}

\hypertarget{polars-and-ml}{%
\section{Polars and ML}\label{polars-and-ml}}

``How do to machine learning with polars?'' is not a well defined
question. ML can be done with many libraries, and the answer depends on
the library you are using. One possibility is converting polars
dataframes to a numpy arrays. This is very easy when dealing with
numerical data. Converting \texttt{pl.Utf8} and \texttt{pl.Categorical}
dtypes is a bit more involved, but still possible. For instance, by
using \texttt{polars.DataFrame.to\_dummies()},
\texttt{polars.get\_dummies()}, or \texttt{polars.Series.to\_dummies()}.

But wait! Isn't the conversion to numpy an expensive operation? Not
terribly, but there is a better way. At the time of writing, ML
libraries such as scikit-learn and xgboost, do not support polars
dataframes as inputs. XGboost, however, does support arrow dataframes.
This is great news since converting polars to arrow is just passing a
pointer. See an example
\href{https://www.rhosignal.com/posts/polars-arrow-xgboost/}{here}.

\hypertarget{polars-and-patsy}{%
\subsection{Polars and Patsy}\label{polars-and-patsy}}

Patsy is a python library for describing statistical models (especially
linear models and generalized linear models) and building design
matrices.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ patsy }\ImportTok{as}\NormalTok{ pt}
\CommentTok{\#make a dataframe}
\NormalTok{data\_pandas }\OperatorTok{=}\NormalTok{ pd.DataFrame(}
\NormalTok{    np.random.randn(}\DecValTok{100}\NormalTok{, }\DecValTok{3}\NormalTok{), }
\NormalTok{    columns}\OperatorTok{=}\NormalTok{[}\StringTok{"y"}\NormalTok{, }\StringTok{"x1"}\NormalTok{, }\StringTok{"x2"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Use patsy to make a design matrix \(X\), and a target vector \(y\) from
a pandas dataframe.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{formula }\OperatorTok{=} \StringTok{\textquotesingle{}y \textasciitilde{} x1 + x2\textquotesingle{}}
\NormalTok{y, X }\OperatorTok{=}\NormalTok{ pt.dmatrices(formula, data\_pandas)}

\NormalTok{X[:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[ 1.        ,  0.99734545,  0.2829785 ],
       [ 1.        , -0.57860025,  1.65143654],
       [ 1.        , -0.42891263,  1.26593626]])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[-1.0856306 ],
       [-1.50629471],
       [-2.42667924]])
\end{verbatim}

Does the same work with polars? Yes!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data\_polars}\OperatorTok{=}\NormalTok{ pl.DataFrame(data\_pandas)}
\NormalTok{X, y }\OperatorTok{=}\NormalTok{ pt.dmatrices(formula, data\_polars)}
\NormalTok{X[:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[-1.0856306 ],
       [-1.50629471],
       [-2.42667924]])
\end{verbatim}

\hypertarget{effect-coding-and-contrasts}{%
\subsection{Effect Coding and
Contrasts}\label{effect-coding-and-contrasts}}

There are
\href{https://stats.oarc.ucla.edu/spss/faq/coding-systems-for-categorical-variables-in-regression-analysis/}{many
ways} to encode categorical variables. For predictions, dummy coding is
enough. If you want to discuss and infer on effect sizes, you may want
to use other coding schemes.

One way to go about is to use the
\href{http://contrib.scikit-learn.org/category_encoders/}{category\_encoders}
library.

We start by making some categorical data.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ string}
\ImportTok{import}\NormalTok{ random}
\NormalTok{cat }\OperatorTok{=}\NormalTok{ pl.Series(}
\NormalTok{    name}\OperatorTok{=}\StringTok{"cat"}\NormalTok{,}
\NormalTok{    values}\OperatorTok{=}\NormalTok{random.choices(}
\NormalTok{        population}\OperatorTok{=}\NormalTok{string.ascii\_letters[:}\DecValTok{5}\NormalTok{], }
\NormalTok{        k}\OperatorTok{=}\NormalTok{data\_polars.height)}
\NormalTok{    ).to\_frame()}
\NormalTok{data\_polars }\OperatorTok{=}\NormalTok{ data\_polars.hstack(cat)}
\NormalTok{data\_polars.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule()
y & x1 & x2 & cat \\
f64 & f64 & f64 & str \\
\midrule()
\endhead
-1.085631 & 0.997345 & 0.282978 & "c" \\
-1.506295 & -0.5786 & 1.651437 & "a" \\
-2.426679 & -0.428913 & 1.265936 & "e" \\
-0.86674 & -0.678886 & -0.094709 & "a" \\
1.49139 & -0.638902 & -0.443982 & "b" \\
\bottomrule()
\end{longtable}

The category encoders currently expects pandas dataframes as input, and
does not support polars dataframes.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ category\_encoders }\ImportTok{as}\NormalTok{ ce}
\NormalTok{encoder }\OperatorTok{=}\NormalTok{ ce.HelmertEncoder()}
\NormalTok{encoder.fit(data\_polars.to\_pandas())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/Users/johnros/workspace/polars_demo/.venv/lib/python3.9/site-packages/category_encoders/base_contrast_encoder.py:126: FutureWarning:

Intercept column might not be added anymore in future releases (c.f. issue #370)
\end{verbatim}

\begin{verbatim}
HelmertEncoder(cols=['cat'],
               mapping=[{'col': 'cat',
                         'mapping':     cat_0  cat_1  cat_2  cat_3
 1   -1.0   -1.0   -1.0   -1.0
 2    1.0   -1.0   -1.0   -1.0
 3    0.0    2.0   -1.0   -1.0
 4    0.0    0.0    3.0   -1.0
 5    0.0    0.0    0.0    4.0
-1    0.0    0.0    0.0    0.0
-2    0.0    0.0    0.0    0.0}])
\end{verbatim}



\end{document}
